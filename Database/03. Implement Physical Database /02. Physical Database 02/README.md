# 2. 물리적 데이터베이스 설계 2

<!--ts-->

- [2. 물리적 데이터베이스 설계 2](#2-물리적-데이터베이스-설계-2)
  - [1. 다단계 인덱스](#1-다단계-인덱스)
  - [2. SQL의 인덱스 정의](#2-sql의-인덱스-정의)
  - [3. 인덱스의 장점과 단점](#3-인덱스의-장점과-단점)
  - [4. 인덱스 선정 지침과 데이터베이스 튜닝](#4-인덱스-선정-지침과-데이터베이스-튜닝)
  - [5. 인덱스를 결정하는데 도움이 되는 몇 가지 지침](#5-인덱스를-결정하는데-도움이-되는-몇-가지-지침)
  - [6. 인덱스가 사용되지 않는 경우](#6-인덱스가-사용되지-않는-경우)
  - [7. 쿼리 튜닝을 위한 추가 지침](#7-쿼리-튜닝을-위한-추가-지침)
  - [8. $B^{+}$ - 트리](#8-b---트리)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 8월 29일 월요일 23시 15분 48초 KST -->

<!--te-->

## 1. 다단계 인덱스

![1](https://user-images.githubusercontent.com/48282185/187222066-eecb02a1-dbd0-4cc4-848a-9c3f4f4b2718.png)

- 인덱스 자체가 클 경우에는 인덱스를 탐색하는 시간도 오래 걸릴 수 있음
- 인덱스 엔트리를 탐색하는 시간을 줄이기 위해서 단일 단계 인덱스를 디스크 상의 하나의 sequential file로 간주하고, 단일 단계 인덱스에 대해서 다시 인덱스를 정의할 수 있음
- 다단계 인덱스는 가장 상위 단계의 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 이런 과정을 반복함 → 한 블록은 한 번에 읽어오는 단위이므로, 한 번만 읽어오면 됨
- 가장 상위 단계 인덱스를 마스터 인덱스(master index)라고 부름
- 마스터 인덱스는 한 블록으로 이루어지기 때문에 주기억 장치에 상주할 수 있음(block 크기 = frame 크기)
- 대부분의 다단계 인덱스는 $B^{+}$- 트리를 사용
  - B는 Balance를 의미, 높이가 다르면 데이터에 따라 찾기까지 걸리는 횟수가 다를 수 있음
  - 모든 노드의 자식의 수를 일정하게 유지
- 데이터 파일의 경우에는 정렬이 안돼있을 수도 있지만, 인덱스는 키 값 기준으로 항상 정렬돼있음
- 위의 예시는 각 블록에서 제일 작은 키 값이 대표값이 된다
- 100을 찾기 위한 과정
  - 10보다 크고 330보다 작음 → 10 따라감
  - 90보다 크고 170보다 작음 → 90 따라감
  - 90보다 크고 110보다 작음 → 90과 100은 같은 블록 내에 있음
  - 총 네 번의 디스크 IO가 필요, 마스터 한 번, 2단계 한 번, 3단계 한 번, 90-100 블록 한 번
- 삽입과 삭제가 일어날 때 인덱스를 조정해야될 수도 있다
  - 모든 애트리뷰트에 대해 다 인덱스로 만들 수 있지만, 이런 오버헤드가 따라옴을 인지해야한다, 그러면 만드는게 효율적인지(검색이 삽입 삭제보다 빈번한지), 비효율적인지 알 수 있다
- 예시

  ![2](https://user-images.githubusercontent.com/48282185/187222048-a12903b2-d959-4610-80ae-eca79f7bf72f.png)

## 2. SQL의 인덱스 정의

- SQL의 CREATE TABLE문에서 PRIMARY KEY절로 명시한 애트리뷰트에 대해서는 DBMS가 자동적으로 기본 인덱스를 생성
- UNIQUE로 명시한 애트리뷰트에 대해서는 DBMS가 자동적으로 보조 인덱스를 생성
- SQL2는 인덱스 정의 및 제거에 관한 표준 SQL문을 제공하지 않음
- 다른 애트리뷰트에 추가로 인덱스를 정의하기 위해서는 DBMS마다 다소 구문이 다른 CREATE INDEX문을 사용해야함
- 다수의 애트리뷰트를 사용한 인덱스 정의

  - 한 릴레이션에 속하는 두 개 이상의 애트리뷰트들의 조합에 대하여 하나의 인덱스를 정의할 수 있음
  - 예시

    ```sql
    CREATE INDEX EmpIndex ON EMPLOYEE (DNO, SALARY);
    ```

    - 이 인덱스는 아래 쿼리에 활용될 수 있음

    ```sql
    SELECT *
    FROM EMPLOYEE
    WHERE DNO = 3 AND SALARY = 4000000;
    ```

    - 이 두 가지 애트리뷰트가 묶여서 자주 조회된다면 인덱스 생성을 고려하자
    - 해당 인덱스를 활용할 수 있는 쿼리

      ```sql
      SELECT *
      FROM EMPLOYEE
      WHERE DNO >= 2 AND DNO <= 3 AND SALARY >= 3000000 AND SALARY <= 4000000;
      ```

      ```sql
      SELECT *
      FROM EMPLOYEE
      WHERE DNO = 3; # DNO의 범위에 대한 쿼리
      ```

    - 이 인덱스를 활용할 수 없는 쿼리

      - DNO없이 SALARY 단독으로 쓰이는 쿼리는 불가능, DNO는 유니크해서 범위나 동등 쿼리에 대해 찾을 수 있지만 SALARY는 중복이 가능하기 때문에 범위나 동등 쿼리에 대해 풀스캔이 필요하다

      ```sql
      SELECT *
      FROM EMPLOYEE
      WHERE SALARY >= 3000000 AND SALARY <= 4000000;
      ```

## 3. 인덱스의 장점과 단점

- 인덱스는 검색 속도를 향상시키지만 인덱스를 저장하기 위한 공간이 추가로 필요하고 삽입, 삭제, 수정 연산의 속도는 저하시킨다
- 소수의 레코드들을 수정하거나 삭제하는 연산의 속도는 향상됨
  - 수정 또는 삭제를 하기 위해서는 어떤 튜플인지 검색될 필요가 있음
- 릴레이션이 매우 크고, 쿼리에 대해서 릴레이션의 튜플들 중 일부(전체 튜플의 2~4%)를 검색하고, where절에 잘 표현되었을 때 특히 성능에 도움이 된다 → 조건을 만족하는 튜플이 많을 경우 인덱스가 별 도움 안됨

## 4. 인덱스 선정 지침과 데이터베이스 튜닝

- 가장 중요한 쿼리들과 이들의 수행 빈도, 가장 중요한 갱신들과 이들의 수행 빈도, 이와 같은 쿼리와 갱신들에 대한 바람직한 성능들을 고려하여 인덱스를 선정함
- 워크로드(어떤 작업을 얼만큼 하느냐) 내의 각 쿼리에 대해 이 쿼리가 어떤 릴레이션들을 접근하는가, 어떤 애트리뷰트를 검색하는가, where절의 선택 / 조인 조건에 어떤 애트리뷰트들이 포함되는가, 이 조건들의 선별력(조건을 만족하는 튜플들의 비율, domain cardinality와 연관)은 얼마인가 등을 고려함
- 워크로드 내의 각 갱신에 대해 이 갱신이 어떤 릴레이션들을 접근하는가, where절의 선택 / 조인 조건에 어떤 애트리뷰트들이 포함되는가, 이 조건들의 선별력은 얼마인가, 갱신의 유형(insert / delete / update), 갱신의 영향을 받는 애트리뷰트 등을 고려함
- 어떤 릴레이션에 인덱스를 생성해야 하는가, 어떤 애트리뷰트를 탐색 키로 선정해야 하는가, 몇 개의 인덱스를 생성해야 하는가, 각 인덱스에 대해 클러스터링 인덱스, 밀집 / 희소 인덱스 중 어느 유형을 선택할 것인가 등을 고려함
- 인덱스를 선정하는 한 가지 방법은 가장 중요한 쿼리들을 차례로 고려해보고, 현재의 인덱스가 최적의 계획에 적합한지 고려해보고, 인덱스를 추가하면 더 좋은 계획이 가능한지 알아봄
- 물리적 데이터베이스 설계는 끊임없이 이루어지는 작업이고 정답은 없다, 운영하면서 깨우쳐야 되는 부분도 많음

## 5. 인덱스를 결정하는데 도움이 되는 몇 가지 지침

- 기본 키는 클러스터링 인덱스를 정의할 훌륭한 후보
- 외래 키도 인덱스를 정의할 중요한 후보
- 한 애트리뷰트에 들어 있는 상이한 값들의 개수가 거의 전체 레코드 수와 비슷하고, 그 애트리뷰트가 동등 조건에 사용된다면 비 클러스터링 인덱스를 생성하는 것이 좋음
- 튜플이 많이 들어 있는 릴레이션에서 대부분의 쿼리가 검색하는 튜플이 2 ~ 4% 미만인 경우에는 인덱스를 생성
- 자주 갱신되는 애트리뷰트에는 인덱스를 정의하지 않는 것이 좋음
- 갱신이 빈번하게 이루어지는 릴레이션에는 인덱스를 많이 만드는 것을 피함
- 후보 키는 기본 키가 갖는 모든 특성을 마찬가지로 갖기 때문에 인덱스를 생성할 후보
- 인덱스는 파일의 레코드들을 충분히 분할할 수 있어야 함
- 정수형 애트리뷰트에 인덱스를 생성, NOT 실수형
- VARCHAR형 애트리뷰트에는 인덱스를 만들지 않음, 값이 클 때를 생각해보면 됨
- 작은 파일에는 인덱스를 만들 필요가 없음
- 대량의 데이터를 삽일할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후에 인덱스들을 다시 생성하는 것이 좋음
- ORDRY BY, GROUP BY 절에서 자주 사용되는 애트리뷰트는 인덱스를 정의할 후보

## 6. 인덱스가 사용되지 않는 경우

- 시스템 카탈로그가 오래 전의 데이터베이스 상태를 나타냄
  - 카탈로그는 시스템의 상태를 나타내는 메타데이터
- DBMS의 쿼리 최적화 모듈이 릴레이션의 크기가 작아서 인덱스가 도움이 되지 않는다고 판단함
  - DBA가 인덱스를 만들었더라도 바로 적용되는 게 아니라 모듈이 판단하고 도움이 될 경우 인덱스를 적용함
- 인덱스가 정의된 애트리뷰트에 산술 연산자가 사용됨
- DBMS가 제공하는 내장 함수가 집단 함수 대신에 사용됨
- NULL값에 대해서는 일반적으로 인덱스가 사용되지 않음

## 7. 쿼리 튜닝을 위한 추가 지침

- DISTINCT절의 사용을 최소화하라
  - 중복 제거는 heavy한 연산
- GROUP BY절과 HAVING절의 사용을 최소화하라
- 임시 릴레이션의 사용을 피하라
  - 쿼리가 많아짐을 의미하고, 그 만큼 디스크 IO가 많아진다
- SELECT \* 대신에 SELECT절에 애트리뷰트 이름들을 구체적으로 명시하라

## 8. $B^{+}$ - 트리

- 노드 하나가 하나의 블럭
- 자료 구조에 정리할거라 그거 보면됨
- 이해하는데 유용한 자료

  [B tree](https://www.slideshare.net/Tech_MX/b-tree-14155416?from_action=save)

  [playground](https://goneill.co.nz/btree.php)

> 출처
>
> - 이화여대 용환승 교수님 강의
> - 홍의경 저, MS SQL Server 기반 데이터베이스 배움터, 생능출판사, 2012년,
> - 이석호 저, 데이터베이스 시스템, 정익사, 2009.
> - A. Silberschatz, H. Korth, S. Sudarshan, "Database System Concepts," 6th Ed., McGraw-Hill, 2010.
> - Elmasri and Navathe, “ Fundamentals of Database Systems”, 6th ed. Addison-Wesley, 2010.
> - C.J.Date, “An Introduction to Database Systems (8th Edition)”, Addison-Wesley, 2003.
> - Won Kim, "Modern Database Systems," ACM Press, 1994

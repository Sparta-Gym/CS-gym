# 1. 물리적 데이터베이스 설계 1

<!--ts-->

- [1. 물리적 데이터베이스 설계 1](#1-물리적-데이터베이스-설계-1)
  - [1. 물리적 데이터 베이스 설계](#1-물리적-데이터-베이스-설계)
  - [2. 보조 기억 장치](#2-보조-기억-장치)
  - [3. 버퍼 관리와 운영체제](#3-버퍼-관리와-운영체제)
  - [4. 디스크 상에서 파일의 레코드 배치](#4-디스크-상에서-파일의-레코드-배치)
  - [5. 파일 조직](#5-파일-조직)
  - [6. 단일 단계 인덱스](#6-단일-단계-인덱스)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 8월 29일 월요일 20시 16분 07초 KST -->

<!--te-->

## 1. 물리적 데이터 베이스 설계

- 논리적인 설계의 데이터 구조를 보조 기억 장치 상의 파일(물리적인 데이터 모델)로 매핑하는 것
- 예상 빈도를 포함하여 데이터베이스 쿼리와 트랜잭션들을 분석함, 뭐가 많이 쓰이느냐에 따라 적용할 수 있는 최적화기법이 달라질 수 있음, 통계 기반으로 스스로 물리 구조를 변화시키는 방향으로 시스템이 발전하고 있다
- 데이터에 대한 효율적인 접근을 제공하기 위하여 저장 구조와 접근 방법들을 다룸
- 특정 DBMS의 특성을 고려하여 진행됨
- 쿼리를 효율적으로 지원하기 위해서 인덱스 구조를 적절히 사용함

## 2. 보조 기억 장치

- 원하는 데이터 검색을 위해 DBMS는 보조 기억 장치 상의 데이터베이스로부터 원하는 데이터를 포함하고 있는 블록을 읽어서 주기억 장치로 가져온다
- 데이터가 변경된 경우에는 블록들을 디스크에 다시 기록함
- 각 파일은 고정된 크기의 블록들로 나누어져서 저장됨
- SSD, 플래시 메모리는 RANDOM ACCESS(데이터가 어디있던지 간에 읽어오는 속도 동일)

  [개발자를 위한 SSD (Coding for SSD) - Part 5 : 접근 방법과 시스템 최적화](https://tech.kakao.com/2016/07/17/coding-for-ssd-part-5/#71-%EC%8B%9C%ED%80%80%EC%85%9C%EA%B3%BC-%EB%9E%9C%EB%8D%A4-io%EC%9D%98-%EC%A0%95%EC%9D%98)

## 3. 버퍼 관리와 운영체제

- 디스크 입출력은 컴퓨터 시스템에서 가장 속도가 느린 작업이므로 입출력 횟수를 줄이는 것이 DBMS의 성능을 향상하는데 매우 중요하다
- 가능하면 많은 블록들을 주기억 장치에 유지하거나, 자주 참조되는 블록들을 주기억 장치에 유지하면 블록 전송 횟수를 줄일 수 있음
- 버퍼는 디스크 블록들을 저장하는데 사용되는 주기억 장치 공간
- 버퍼 관리자는 운영체제의 구성요소로서 주기억 장치 내에서 버퍼 공간을 할당하고 관리하는 역할을 맡는다
- 운영체제에서 버퍼 관리를 위해 흔히 사용되는 LRU알고리즘은 데이터베이스를 위해 항상 우수한 성능을 보이지는 않는다(DBMS에서는 이게 최적이 아닐 수 있기에 별도의 교체 알고리즘을 쓴다)
- DBMS가 관리하는 메타데이터(=스키마)는 자주 사용되는 정보로 주기억장치에 상주해있는 것이 좋고 어떤 정보들이 버퍼에 있는 것이 좋은지 결정해줄 필요가 있다, 하지만 운영체제는 이런 정보를 모르기 때문에 통상적으로 DBMS들은 버퍼를 따로 관리한다

## 4. 디스크 상에서 파일의 레코드 배치

![Untitled](https://user-images.githubusercontent.com/48282185/187189230-78c82105-e60c-4a38-835b-c1e2fef7c384.png)

- 릴레이션의 애트리뷰트는 고정 길이 또는 가변 길이의 필드로 표현됨
- 연관된 필드들이 모여서 고정 길이 또는 가변 길이의 레코드가 됨
- 한 릴레이션을 구성하는 레코드들의 모임을 파일이라고 부르는 블록들의 모임에 저장됨
- 제어 정보가 파일 헤더에 저장된다
- 블록들끼리는 디스크 상에서 대부분 연속적으로 위치해있지 않다
- 디스크에서 인접한 블록들을 읽는 경우에는 입출력속도가 빠르므로 블록들이 인접하도록 한 파일의 블록들을 재조직할 수 있음
- 같은 파일의 블록들끼리는 링크드 리스트 형태로 연결되있다
- BLOB(Binary Large Object)
  - 이미지, 동영상 등 대규모 크기의 데이터를 저장하는데 사용
- 채우기 인수(fill factor)
  - 각 블록에 레코드를 채우는 공간의 비율
  - 나중에 레코드가 삽일될 때 기존의 레코드들을 이동하는 가능성을 줄이기 위해서(정렬 유지하는 데이터들은 중간 삽입해줘야 하는데 꽉 채워놨다면 뒤로 밀고 중간 삽입해야되는데 꽉 안 채워놨다면 그냥 삽입하면 됨)
  - 몇으로 정할지는 데이터의 성격에 따라 달라지기 때문에 운영하면서 최적의 값을 찾아야함
- 고정 길이 레코드

  ![Untitled 1](https://user-images.githubusercontent.com/48282185/187189184-82eb9757-9883-412f-ac6f-06fc5b18fbad.png)

  - 레코드 i를 접근하기 위해서는 n \* (i-1) + 1위치에서 레코드를 읽음(n은 레코드의 크기)
  - 레코드 i가 삭제되면 제일 마지막에 있는 레코드로 그 자리를 메꾼다, 그냥 놔두면 공간의 낭비이기 때문

- 파일 내 클러스터링(intra-file clustering)
  - 한 파일 내에서 함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 가까운 곳에 모아두는 것
  - 같이 많이 조회되는 레코드끼리 묶어서 같은 블록에 저장해높으면 성능이 좋아진다
- 파일 간 클러스터링(inter-file clustering)
  - 논리적으로 연관되어 함께 검색될 가능성이 높은 두 개 이상의 파일에 속한 레코드들을 디스크 상에서 물리적으로 가까운 곳에 저장하는 것
  - 구현이 굉장히 어렵고, 연관이라는 것이 모호하고 연관의 우선순위도 모호하기 때문에 이론적인 컨셉이라고 생각하면 될 듯

## 5. 파일 조직

- 파일 조직 유형
  - heap file
  - sequential file
  - indexed sequential file
  - hash file
  - 이외에 무수히 많다
- heap file

  - 가장 단순한 파일 조직
  - 일반적으로 레코들이 삽입되는 순서대로 파일에 저장됨
  - 삽입: 새로 삽입되는 레코드는 파일을 가장 끝에 삽입됨 → 삽입에서는 최적의 성능
  - 검색: 원하는 레코드를 찾기 위해서는 모든 레코드들을 순차적으로 접근해야함
  - 삭제: 원하는 레코드들 찾은 후에 그 레코드를 삭제하고, 삭제된 레코드가 차지하던 공간을 재사용하지 않음 → 순서를 유지하려면 삭제된 레코드 이후로 싹 다 밀어서 붙여야되는데 배보다 배꼽이다, 결국 공간의 낭비가 발생함
  - 좋은 성능을 유지하기 위해서 주기적으로 재조직할 필요가 있음
  - 성능

    - 쿼리에서 모든 레코드들을 참조하고, 레코드들을 접근하는 순서는 중요하지 않을 때

      ```sql
      select * from employee;
      ```

    - 특정 레코드를 검색하는 경우에는 비효율적

      - 원하는 블록을 찾기 위해서 평균적으로 b/2개의 블록을 읽어야함(best case + worst case / 2)

      ```sql
      select * from employee where empno = 1365;
      ```

    - 예시

      ![Untitled 2](https://user-images.githubusercontent.com/48282185/187189186-813ceb59-fd2d-4cbf-8764-13bb9f912592.png)

    - 몇 개의 레코드들을 검색하는 경우에도 비효율적
    - 조건에 맞는 레코드를 이미 한 개 이상 검색했더라도 파일을 마지막 블록까지 읽어서 원하는 레코드가 존재하는지 확인해야하기 때문에 b개의 블록을 모두 읽어야 함
    - 정리
      - 삽입 - 효율적
      - 삭제 - 비효율적
      - 탐색 - 비효율적
      - 순서대로 검색 - 비효율적
      - 특정 레코드 검색 - 비효율적

- sequential file
  - 레코드들이 하나 이상의 필드(애트리뷰트) 값에 따라 순서대로 저장된 파일, 보통 키 값이 정렬의 기준이된다
  - 레코드들이 일반적으로 레코드의 탐색 키(search key) 값의 순서에 따라 저장됨
  - 탐색 키는 sequential file을 정렬하는데 사용되는 필드를 의미
  - 삽입 연산은 삽입하려는 레코드의 순서를 고려해야 하기 때문에 시간이 많이 걸릴 수 있음 → 삽입할 위치를 찾아야하기 때문
  - 삭제 연산은 삭제된 레코드가 사용하던 공간을 빈 공간으로 남기기 때문에 heap file과 마찬가지로 주기적인 재조직이 필요
  - 기본 인덱스가 sequential file에 정의되지 않는 한 순차 파일을 데이터베이스 응용을 위해 거의 사용되지 않음
  - 성능
    - 키가 검색 기준이 될 때는 키를 기준으로 정렬돼있는 상태이기때문에 이진 탐색을 통해 검색할 수 있고, 키 이외의 애트리뷰트의 경우는 저장 순서와 무관하기 때문에 풀스캔이 필요하다
  - 정리
    - 삽입 - 비효율
    - 삭제 - 비효율
    - 탐색 키를 기반으로 검색 - 효율
    - 탐색 키가 아닌 필드를 기반으로 검색 - 비효율
  - 예시
    ![Untitled 3](https://user-images.githubusercontent.com/48282185/187189198-b8a64852-c4ba-4634-882c-d47f5604d16a.png)

## 6. 단일 단계 인덱스

![Untitled 4](https://user-images.githubusercontent.com/48282185/187189203-b6fbf2fd-a68f-4f86-91a2-de743e2b6d08.png)

![Untitled 5](https://user-images.githubusercontent.com/48282185/187189207-f808f692-0c8e-4e3a-8da5-a659ae00287e.png)

- 파일의 내용을 어떻게 저장하냐느냐에 따른 방법론에는 한계가 있음(heap, sequential file) 그래서 인덱스 파일을 하나 따로 둬서(하나만 두기에 단일 단계, 여러 개 두면 다단계) 따로 관리한다
- 인덱스된 sequential file은 인덱스를 통해서 임의의 레코드를 접근할 수 있는 파일
- 단일 단계 인덱스의 각 엔트리는 <탐색 키, 레코드에 대한 포인터>로 구성됨
- 엔트리들은 탐색 키 값의 오름차순으로 정렬됨
- 인덱스의 크기는 데이터 파일의 크기에 비해 훨씬 작음(주소가 커봤자 64bit 운영체제에서 8byte)
- 하나의 파일(릴레이션)에 여러 개의 인덱스들을 정의할 수 있다, 위 그림에서는 인덱스가 하나이지만 여러 개의 인덱스를 만들 수 있다는 이야기 최대 애트리뷰트의 개수만큼 만들 수 있음
  - 도메인의 카디날리티를 고려해서 만들어야한다, 중복 요소가 여러개로 구성된 배열을 생각해보면, ‘이것을 이진 탐색한다고 효용이 높아질까?’에 대해 생각해보면 됨
  - 도메인의 카디날리티가 높다라는 것은 중복이 적다는 이야기인데, 카디날리티가 양을 나타내는 것을 뜻하는데, 양이 많다 → 구간이 넓다 → 중복이 적어진다 반대로, 양이 적다 → 구간이 좁다 → 중복이 커진다, 넓은 영역에서 여러 엔트리들이 값을 가지는 것과 좁은 영역에서 여러 엔트리들이 값을 가지는 것을 생각해볼 때 어떤 것이 중복이 많이 발생할지 따져보면 헷갈리지 않는다 → 주관적인 생각임
- 어떤 애트리뷰트를 통해 자주 조회되는지에 따라 어떤 애트리뷰트를 인덱스로 설정할 지 알 수 있다
- 기본 키로 인덱스를 구성했을 때는 인덱스 파일의 탐색키가 고유하지만 다른 애트리뷰트로 인덱스를 구성했을 때는 탐색 키가 고유하지 않을 수 있다, 다만 가리키는 릴레이션의 엔트리가 다르면 된다
- 인덱스의 엔트리들은 탐색 키의 오름차순으로 저장되어 있으므로 이진 탐색을 이용할 수 있다
- 기본 인덱스(primary index)
  - 탐색 키가 데이터 파일의 기본 키인 인덱스를 기본 인덱스라고 부른다
  - 기본 인덱스는 키본 키의 값에 따라 정렬된 데이터 파일에 대해 정의된다
  - 기본 인덱스는 흔히 희소 인덱스로 유지할 수 있음
    - 회소 인덱스를 만들려면 데이터 파일이 정렬이 돼있어야함, 흔히 기본 키로 데이터 파일이 정렬돼있는 경우가 많음
  - 각 릴레이션마다 최대한 한 개의 기본 인덱스를 가질 수 있음
- 희소(sparse) 인덱스 vs 밀집(dense) 인덱스

  ![Untitled 6](https://user-images.githubusercontent.com/48282185/187189215-d54b1f04-1143-4226-a549-c23041b56d7f.png)

  - 모든 탐색 키에 대해 인덱스를 만드는 것을 밀집 인덱스, 탐색키의 대표값들로 인덱스를 만드는 것을 희소 인덱스라고 하는데 위 예시의 경우 모든 탐색키가 인덱스로 만들어진게 아니므로 희소 인덱스라고 할 수 있다
  - 블록의 시작 키를 대표 인덱스로 희소 인덱스를 만들어 놓은 형태
  - 저렇게 해도 인덱스에 없는 탐색키를 찾을 수 있는데, 정렬돼있기 때문에 어느 구간 사이에 있는지만 보면 되기 때문이다
    - 예를들어 20을 찾는다 → 10과 30사이에 있으면 있는거고 없으면 없는 것임
    - 이게 희소 인덱스를 만들기 위해 정렬돼있어야하는 이유

- 예시

  ![Untitled 7](https://user-images.githubusercontent.com/48282185/187189219-b966c2f8-a919-489f-ba54-21010e8fa217.png)

  - 블록포인터는 데이터 파일에서 엔트리의 주소를 의미
  - 데이터파일이 정렬돼있지 않아도 sequential file에 비해 성능향상이 된 것을 알 수 있다

- 클러스터링 인덱스(clustering index)

  - 탐색 키 값에 따라 정렬된 데이터 파일에 대해 정의됨
  - 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함됨
  - 인덱스 엔트리와 데이터 엔트리가 같은 정렬 기준으로 정렬돼있어야함
  - 희소 인덱스의 경우 이미 클러스터링 인덱스를 만든 것임
  - 범위 쿼리에 유용
  - 범위의 시작 값에 해당하는 인덱스 엔트리를 먼저 찾고, 범위에 속하는 인덱스 엔트리들을 따라가면서 레코드들을 검색할 때 디스크에서 읽어오는 블록의 수가 최소화됨
  - 어떤 인덱스 엔트리에서 참조되는 데이터 블록을 읽어오면 그 데이터 블록에 들어 있는 대부분의 레코드들은 범위를 만족함
  - 예시

    ![Untitled 8](https://user-images.githubusercontent.com/48282185/187189223-31a85e91-29be-43c8-954c-f791d3e06aad.png)

- 보조 인덱스(secondary index)

  ![Untitled 9](https://user-images.githubusercontent.com/48282185/187189225-5d812837-83b8-4a45-8a6c-92d25d88313b.png)

  - 한 파일은 한 가지 필드들의 조합에 대해서만 정렬될 수 있음
  - 보조 인덱스는 탐색 키 값에 따라 정렬되지 않은 데이터 파일에 대해 정의된다
  - 보조 인덱스는 일반적으로 밀집 인덱스이므로 같은 수의 레코드들을 접근할 때 보조 인덱스를 통하면 기본 인덱스를 통하는 경우보다 디스크 접근 횟수가 증가할 수 있음
  - 밀집 인덱스의 성능 예시

    ![Untitled 10](https://user-images.githubusercontent.com/48282185/187189227-52cd23f0-7e28-4fe3-bf9f-1f106028a926.png)

- 희소 인덱스 vs 밀집 인덱스
  - 희소 인덱스는 각 데이터 블록마다 한 개의 엔트리를 갖고, 밀집 인덱스는 각 레코드마다 한 개의 엔트리를 갖는다
  - 레코드의 길이가 블록 크기보다 훨씬 작은 일반적인 경우에는 희소 인덱스의 엔트리 수가 밀집 인덱스의 엔트리 수보다 훨씬 적음
  - 희소 인덱스는 일반적으로 밀집 인덱스에 비해 인덱스 단계 수가 1정도 적으므로 인덱스 탐색 시 디스크 접근 수가 1만큼 적을 수 있음
  - 희소 인덱스는 클러스터링 개념이 들어가야하기때문에 모든 애트리뷰트가 희소 인덱스의 대상이 될 수 없다
  - 희소 인덱스는 밀집 인덱스에 비해 모든 갱신과 대부분의 쿼리에 대해 더 효율적이다
  - 쿼리에서 인덱스가 정의된 애트리뷰트만 검색하는 경우에는 데이터 파일을 접근할 필요없이 인덱스만 접근해서 쿼리를 수행할 수 있으므로 밀집 인덱스가 희소 인덱스보다 유리
    - 예시로 COUNT 쿼리
  - 한 파일은 한 개의 희소 인덱스와 다수의 밀집 인덱스를 가질 수 있다
- 클러스터링 인덱스 vs 보조 인덱스
  - 클러스터링 인덱스는 희소 인덱스일 경우가 많으며 범위 질의 등에 좋다
  - 보조 인덱스는 밀집 인덱스이므로 일부 쿼리에 대해서는 데이터 파일을 접근할 필요 없이 처리할 수 있다

> 출처
>
> - 이화여대 용환승 교수님 강의
> - 홍의경 저, MS SQL Server 기반 데이터베이스 배움터, 생능출판사, 2012년,
> - 이석호 저, 데이터베이스 시스템, 정익사, 2009.
> - A. Silberschatz, H. Korth, S. Sudarshan, "Database System Concepts," 6th Ed., McGraw-Hill, 2010.
> - Elmasri and Navathe, “ Fundamentals of Database Systems”, 6th ed. Addison-Wesley, 2010.
> - C.J.Date, “An Introduction to Database Systems (8th Edition)”, Addison-Wesley, 2003.
> - Won Kim, "Modern Database Systems," ACM Press, 1994

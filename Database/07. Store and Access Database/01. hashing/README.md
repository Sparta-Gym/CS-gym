# 1. 데이터베이스의 저장과 접근: 해싱

<!--ts-->

- [1. 데이터베이스의 저장과 접근: 해싱](#1-데이터베이스의-저장과-접근-해싱)
  - [1. 해싱](#1-해싱)
  - [2. 버킷 해싱](#2-버킷-해싱)
  - [3. 확장성 해싱(Extendible hashing)](#3-확장성-해싱extendible-hashing)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 9월  3일 토요일 19시 23분 41초 KST -->

<!--te-->

## 1. 해싱

- 다른 레코드의 참조 없이 목표 레코드의 접근을 직접 지원
  - direct file이라고 함
- 키값과 레코드 주소 사이의 매핑관계를 함수로 설정
- 삽입, 검색에 모두 이용

## 2. 버킷 해싱

- 버킷(bucket)
  - 하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 파일의 한 구역(= 블록)
  - 버킷 크기
    - 저장 장치의 물리적 특성과 한 번 접근으로 추출 가능한 레코드 수를 고려
- 버킷 해싱
  - hash(키) = 버킷 주소
- 충돌(collision)
  - 상이한 레코드들을 같은 주소(버킷)로 변환
  - synonym = 같은 버킷에 있는 레코드들
  - 버킷이 꽉차면 새로운 공간을 할당하고 링크드 리스트 형태로 연결해준다(overflow bucket)

## 3. 확장성 해싱(Extendible hashing)

- 충돌에 대처하기 위해 제안된 기법
- 레코드 검색은 최대 2번의 디스크 접근만 필요
- 레코드들의 수가 얼마가 될지 예상할 수 없기에 반드시 확장성이 고려되어야함
- 레코드의 수가 늘어나면 버킷의 개수 늘리고, 줄어들면 개수도 줄인다 ⇒ 확장성
- 해시함수를 확장성을 고려해서 설계하여 버켓의 개수에 제한을 두지 않음
- 여기서 확장은 2배씩 늘린다($2^n$)
  - linear하게 늘리는 방법도 있음
- 모조 키(pseudo key)
  - 확장성 해싱 함수는 키 값을 일정 길이의 비트 스트링(pseudo key)으로 변환한다
  - pseudo key의 처음 d비트를 디렉터리의 인덱스로 사용
- 디렉토리(directory)
  - 헤더에 현재 디렉터리 깊이 d(전역 깊이, global depth)를 유지
  - $2^d$개의 버킷들을 가리킬 수 있는 포인터 엔트리로 구성됨
  - 디스크에 저장
- 버킷(bucket)

  - 해시 함수의 결과로 나온 비트스트링의 앞 d비트 만큼을 사용하여 버킷을 찾는데 쓴다
  - d가 3인 디렉토리는 총 8개의 버킷을 가질 수 있다

    ![1](https://user-images.githubusercontent.com/48282185/188266377-3fb2df2f-f5cb-4ae8-bb7c-40268abd7c5a.png)

  - 헤더에 현재의 버킷 깊이 p(지역 깊이, local depth)를 유지
  - 각 버킷에 저장된 레코들의 모조 키들은 처음 p비트가 모두 동일
  - 예를 들어 100으로 시작하는 비트스트링끼리 같은 버켓에 저장되고,001로 시작하는 비트스트링끼리는 같은 버켓에 저장된다
  - 버킷의 깊이 p가 의미하는 바는 p가 3인 경우 키의 앞 세자리를 모두 키로 사용함, 위의 예시에서 000과 001은 세자리를 모두 사용하였고, p가 2인 경우 키의 앞 두자리를 모두 키로 사용한 경우이고, 010과 011은 앞 두비트가 01로 같으므로 같은 버켓에 저장됨, 마지막으로 p가 1인 경우에는 키의 앞 한자리를 키로 사용한 경우이고, 100, 101, 110, 111모두 앞 한 비트가 1로 같으므로 같은 버켓에 저장됨 디렉터리의 깊이가 3이라해서 키의 앞 세자리를 모두 이용하는게 아니라 최대 세자리까지 이용하는 버켓이 있다로 이해하면 된다
    - 이렇게 하는 이유는 버킷의 개수는 한정적인데, 엔트리가 필요할 때마다 확장해줘야되고, 할당된 모든 버켓이 사용된게 아니기 때문에, 확장 시 실제로 버켓을 할당하는 것은 비효율적이다, 그래서 확장할 때는 가리킬 수 있는 개수인 디렉터리만 확장시키고, 버켓은 확장되지않는다
    - 010과 011은 현재 같은 것으로 취급되고 있는데 이것들이 가리키는 버켓이 꽉 찬 상황에서 010이 새로 들어왔다고 가정했을 때 더 이상 저장할 수 있는 공간이 없으므로 새로운 버켓 하나를 할당받고 010과 011의 깊이를 1증가시킨다, 오버플로된 버켓은 010과 연결시키고, 새로 할당받은 버켓은 011과 연결시켜서 011로 시작하는 모든 데이터를 새로 할당 받은 버킷으로 옮긴다
  - doubling 과정

    - 세비트를 쓰고 있는 상황에서 000으로 시작하는 키가 계속들어와서 오버플로가 났을 때 새로운 버켓을 할당해줘야한다

      ![2](https://user-images.githubusercontent.com/48282185/188266374-a2923bf4-ffc4-4079-b319-027ebb31fdf5.png)

    - 버켓 깊이 p를 1증가시키고 버켓을 분할한다
    - 빈 버켓을 할당 받고 p는 p+1로 변경
    - 모조 키가 0001로 시작하는 모든 레코드를 새로운 버켓으로 이동
    - 이 때 d < p + 1이 되므로 d를 1증가시켜 디렉토리를 2배확장 ⇒ doubling
    - 확장된 디렉터리의 모든 포인터를 재조정한다

  - 키값이 편향되면 한 버켓에 쏠려서 디렉터리가 계속 커질 수 있음
  - 레코드가 삭제되면서 사용되지 않는 버켓이 생기면 깊이를 감소시키고 합치고, 같은 것을 가리키도록 조정한다 ⇒ 확장의 반대로하면 됨

> 출처
>
> - 이화여대 용환승 교수님 강의
> - 홍의경 저, MS SQL Server 기반 데이터베이스 배움터, 생능출판사, 2012년,
> - 이석호 저, 데이터베이스 시스템, 정익사, 2009.
> - A. Silberschatz, H. Korth, S. Sudarshan, "Database System Concepts," 6th Ed., McGraw-Hill, 2010.
> - Elmasri and Navathe, “ Fundamentals of Database Systems”, 6th ed. Addison-Wesley, 2010.
> - C.J.Date, “An Introduction to Database Systems (8th Edition)”, Addison-Wesley, 2003.
> - Won Kim, "Modern Database Systems," ACM Press, 1994

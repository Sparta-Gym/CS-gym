# 2. SQL

## 1. SQL 개요

- SQL은 현재 DBMS 시장에서 관계 DBMS가 압도적인 우위를 차지하는데 중요한 요인 중 하나
- SQL은 IBM연구소에서 1974년에 System R이라는 관계 DBMS 시제품을 연구할 때 관계 대수와 관계 해석을 기반으로 집단 함수, 그룹화, 갱신 연산 등을 추가하여 개발한 언어
- 1986년에 ANSI에서 SQL 표준을 채택함으로서 SQL이 널리 사용되는데 기여
- 다양한 상용 관계 DBMS마다 지원하는 SQL기능에 다소 차이가 있음
- SQL은 비절차적 언어(선언적 언어)이므로 사용자는 자신이 원하는 바(what)만 명시하며, 원하는 것을 처리하는 방법(how)은 명시할 수 없음
- 관계 DBMS는 사용자가 입력한 SQL문을 번역하여 사용자가 요구한 데이터를 찾는데 필요한 모든 과정을 담당
- 자연어에 가까운 구문을 사용하여 질의를 표현할 수 있음
- 두 가지 인터페이스
  - 대화식 SQL(interactive SQL)
  - 내장된 SQL(embedded SQL)

## 2. SQL의 구성 요소

![1](https://user-images.githubusercontent.com/48282185/186123572-190500d2-f6d8-4d7f-9d03-7eb75fd75d65.png)

- 데이터 정의어

  ![2](https://user-images.githubusercontent.com/48282185/186123569-78d30df3-1e03-4d4c-a705-c5b5fb71bdfe.png)

  - 스키마

    - 데이터베이스 스키마는 관계형 데이터베이스 내에서 데이터가 구성되는 방식을 정의한다 여기에는 테이블 이름, 필드, 데이터 유형 및 이러한 엔티티 간의 관계와 같은 논리적 제약 조건이 포함된다 스키마는 일반적으로 시각적 표현을 사용하여 데이터베이스의 아키텍처를 전달하여 조직의 데이터 관리 분야의 기반이 된다. 이러한 데이터베이스 스키마 설계 프로세스는 데이터 모델링이라고도 한다.

      [What is a Database Schema?](https://www.ibm.com/cloud/learn/database-schema)

  - 스키마의 생성과 제거
    - SQL2에서는 동일한 데이터베이스 응용에 속하는 릴레이션, 도메인, 제약조건, 뷰, 권한 등을 그룹화하기 위해서 스키마 개념을 지원
  - 제약 조건
    - 원래는 컬럼들이 특정 도메인에 속해야되고, 도메인에 제약 조건을 거는것이 맞는데 편의성을 위해 도메인을 생략하고 타입으로 바로 지정하는 경우가 대부분임
    ```sql
    DNO INTEGER CHECK (DNO IN (1,2,3,4)) DEFAULT 1,
    ```
    - 참조 무결성 제약조건 유지
      - 외래키로 참조하고 있는 컬럼이 origin에서 변경되었을 때, 참조 하고 있는 컬럼들에게 취해질 행동을 명시
      - ON DELETE(UPDATE) NO ACTION
      - ON DELETE(UPDATE) CASCADE
      - ON DELETE(UPDATE) SET NULL
      - ON DELETE(UPDATE) SET DEFAULT
    - 무결성 제약조건의 추가 및 삭제
      ```sql
      ALTER TABLE STUDENT ADD CONSTRAINT STUDENT_PK PRIMARY KEY (STNO);
      ```
      - 제약 조건에 이름을 명명하는 이유는 제약 조건에 위배됬을 때 어떤 제약조건을 어겼는지 사용자에게 알려주기 위한 용도, 삭제할 때 명시하기 위한 용도 등 다양한 용도가 있음

- 데이터 조작어
- 데이터 제어어

## 3. SELECT문

![3](https://user-images.githubusercontent.com/48282185/186123565-85458e3c-e563-4bb9-94a4-c7b0c594576d.png)

- 관계 데이터베이스에서 정보를 검색하는 SQL문
- 관계 대수의 selection과 의미가 완전히 다름
- 관계 대수의 selection, projection, cartesian product 등을 결합한 것
- 관계 데이터베이스에서 가장 자주 사용됨
- 여러 가지 질의들의 결과를 보이기 위해서 관계 데이터베이스 상태를 사용함
- 별칭(alias)
  - 서로 다른 릴레이션에 동일한 이름을 가진 애트리뷰트가 속해 있을 때 애트리뷰트 이름을 구분하는 방법
- where절에서 연산자 우선순위
  - 비교연산자(0), NOT(1), AND(2), OR(3)
- null값
  - null값을 포함한 다른 값과 null값을 +, -들을 사용하여 연산하면 결과는 null
  - count(\*)를 제외한 aggregate function들은 null값을 무시함, 값하고 연산이 안되기 때문에 예상치 않은 결과를 초래할 수 있음
  - 어떤 애트리뷰트에 들어있는 값이 null인가 아닌가 비교하기 위해 ‘=’연산자를 사용하면 안됨, 비교가 불가능한 특별한 값, 그냥 들어있는지 아닌지를 나타내기 위한 용도이지 비교를 위한 용도로는 사용될 수 없음(NULL = NULL의 결과는 false임)
  - 그래서 null인지 확인하기 위해 IS NULL이라는 특별한 문법을 사용
- join

  ![4](https://user-images.githubusercontent.com/48282185/186123560-211037be-d063-4059-9429-0c626f15ad13.png)

  - join은 두 개 이상의 릴레이션으로부터 연관된 튜플들을 결합
  - join의 일반적인 형식은 두 개 이상의 릴레이션들이 열거되고, 두 릴레이션에 속하는 애트리뷰트들을 비교하는 join 조건이 where절에 포함됨
  - join 조건은 두 릴레이션 사이에 속하는 애트리뷰트 값들을 비교 연산자로 연결한 것
  - 가장 흔히 사용되는 비교 연산자는 ‘=’이다
  - join 조건을 생략했을 때와 조인 조건을 틀리게 표현했을 때는 카티션 곱이 생성된다
  - join 질의가 수행되는 과정을 개념적으로 살펴보면 먼저 join 조건을 만족하는 튜플들을 찾고, 이 튜플들로부터 select절에 명시된 애트리뷰트들만 projection하고, 필요하다면 중복을 배제하는 순서로 진행됨
  - join 조건이 명확해지도록 애트리뷰트 이름 앞에 릴레이션 이름이나 튜플변수를 사용하는 것이 바람직
  - 두 릴레이션의 join 애트리뷰트 이름이 동일하다면 반드시 애트리뷰트 이름 앞에 릴레이션 이름이나 튜블 변수를 사용해야함

- self join
  - 한 릴레이션에 속하는 튜플을 동일한 릴레이션에 속하는 튜플들과 조인하는 것
  - 실제로는 한 릴레이션이 접근되지만 from절에 두 릴레이션이 참조되는 것처럼 나타내기 위해서 그 릴레이션에 대한 별칭을 두개 지정해야 함
- nested query

  - 외부 질의의 where절에 다시 select문이 오는 쿼리
  - 쿼리의 결과는 릴레이션이기 때문에 이론적으로 릴레이션이 오는 자리에 쿼리가 올 수 있다
  - 서브 쿼리라고도 함
  - insert, delete, update문에도 사용될 수 있음
  - 중첩 질의의 결과로 한 개의 스칼라값(릴레이션이 아닌 단일 값 리턴), 한 개의 애트리뷰트로 이루어진 릴레이션, 여러 애트리뷰트로 이루어진 릴레이션이 반환될 수 있음

    ![5](https://user-images.githubusercontent.com/48282185/186123557-7317afa7-bf43-45b3-b72c-3c5f4f5eb978.png)

    - 여기서 스칼라값은 “과장"이 된다
    - 한 개의 애트리뷰트로 이루어진 릴레이션이 반환되는 경우(결과 → 집합)

      - 중첩 질의의 결과로 한 개의 애트리뷰트로 이루어진 다수의 튜플들이 반환될 수 있음
      - 외부 질의의 where절에서 IN, ANY(SOME), ALL, EXISTS와 같은 연산자를 사용해야함
      - 키워드 IN은 한 애트리뷰트가 값들의 집합에 속하는가를 테스트할 때 사용됨

        ![6](https://user-images.githubusercontent.com/48282185/186123555-997ac623-379f-4634-8b6c-a77584b5b144.png)

      - 한 애트리뷰트가 값들의 집합에 속하는 하나 이상의 값들과 어떤 관계를 갖는가를 테스트하는 경우에는 ANY를 사용, 하나라도 만족하면 true, IN은 존재 여부를 검사하고(=), ANY는 비교 연산자를 만족하는지 검사

        ![7](https://user-images.githubusercontent.com/48282185/186123553-d03077ba-95a5-40a6-ae69-fb44d31253fc.png)

      - 한 애트리뷰트가 값들의 집합에 속하는 모든 값들과 어떤 관계를 갖는가를 테스트하는 경우에는 ALL을 사용

        ![8](https://user-images.githubusercontent.com/48282185/186123549-8700c6cf-b90a-4cf3-9e83-6afaa946148b.png)

      - 예시

        ![9](https://user-images.githubusercontent.com/48282185/186123544-3111911f-fef4-4601-8146-1b434c4db4f4.png)

        - DEPARTMENT와 EMPLOYEE를 DNO를 이용해서 join해서 부서명이 영업 또는 개발인 사원들의 이름을 뽑은 것과 같다
        - 서브 쿼리가 먼저 수행되고 나서 외부 쿼리가 수행된다 ⇒ 절차가 있다

    - 여러 애트리뷰트들로 이루어진 릴레이션이 반환되는 경우(결과 → 릴레이션)

      ![10](https://user-images.githubusercontent.com/48282185/186123540-2cea25b7-d2c4-406c-9dd6-fdc3d10a29a7.png)

      - 중첩 질의의 결과로 여러 애트리뷰트들로 이루어진 릴레이션이 반환되는 경우에는 EXISTS연산자를 사용하여 중첩 질의의 결과가 빈 릴레이션인지 여부를 검사함
      - 중첩 질의의 결과가 빈 릴레이션이 아니면 참이 되고, 그렇지 않으면 거짓이 된다
      - 서브쿼리에서 나오는 튜플의 존재 유무가 중요

  - 상관 중첩 질의(correlated nested query)

    ![11](https://user-images.githubusercontent.com/48282185/186123534-61b6f91a-f359-4f5d-95d3-ab70c369bf91.png)

    - 중첩 질의의 where절에 있는 프레디키드에서 외부 질의에 선왼된 릴레이션의 일부 애트리뷰트를 참조하는 질의
    - 중첩 질의의 수행 결과가 단일 값이든, 하나 이상의 애트리뷰트로 이루어진 릴레이션이든 외부 질의로 한 번만 결과를 반환하면 상관 중첩 질의가 아님
    - 상관 중첩 질의에서는 외부 질의를 만족하는 각 튜플이 구해진 후에 중첩 질의가 수행되므로 상관 중첩 질의는 외부 질의를 만족하는 튜플 수 만큼 여러 번 수행될 수 있음
    - 외부 쿼리 릴레이션의 튜플 하나 하나에 대해서 서브쿼리가 수행됨, 카티시안 곱하고 똑같다

## 4. INSERT, DELETE, UPDATE 문

- insert 문

  - 기존의 릴레이션에 튜플을 삽입
  - 참조되는 릴레이션에 튜플이 삽입되는 경우에는 참조 무결성 제약조건의 위배가 발생하지 않으나 참조하는 릴레이션에 튜플이 삽입되는 경우에는 참조 무결성 제약조건을 위배할 수 있음
  - 릴레이션에 한 번에 한 튜플씩 삽입하는 것과 한 번에 여러 개의 튜플들을 삽입할 수 있는 것으로 구분
  - 한 번에 여러 개의 튜플 삽입하는 예시

    ![12](https://user-images.githubusercontent.com/48282185/186123510-c2e4385a-d365-473b-97ef-ffc1a1f77176.png)

    - 연봉 3천만 이상인 모든 employee의 이름, 연봉, 직급을 HIGH_SALARY테이블에 삽입해라
    - select문의 결과가 릴레이션이니 이 릴레이션의 튜플들이 전부 새로운 테이블의 튜플로 들어간다

- delete 문
  - 삭제 연산은 한 릴레이션으로부터 한 개 이상의 튜플들을 삭제함
  - 참조되는 릴레이션의 삭제 연산의 결과로 참조 무결성 제약조건이 위배될 수 있으나, 참조하는 릴레이션에서 튜플을 삭제하면 참조 무결성 제약조건을 위배하지 않음
- update 문
  - 한 릴레이션에 들어 있는 튜플들의 애트리뷰트 값들을 수정
  - 기본 키나 외래 키에 속하는 애트리뷰트의 값이 수정되면 참조 무결성 제약조건을 위배할 수 있음

## 5. trigger, assertion

- trigger
  - 명시된 이벤트(데이터베이스의 갱신 등)가 발생할 때마다 DBMS가 자동적으로 수행하는 사용자가 정의하는 문(procedure)
  - 데이터베이스의 무결성을 유지하기 위한 일반적이고 강력한 도구
  - 테이블 정의시 표현할 수 없는 비즈니스 규칙들을 시행하는 역할
  - 트리거를 명시하려면 트리거를 활성화시키는 사건인 이벤트, 트리거가 활성화되었을 때 수행되는 테스트인 조건, 트리거가 활성화되고 조건이 참일 때 수행되는 문(procedure)인 동작을 표현해야 함
  - 트리거를 이벤트 - 조건 - 동작(ECA) 규칙이라고도 부름
    - Event, Condition, Action
  - SQL3 표준에 포함되었으며 대부분의 상용 관계 DBMS에서 제공하는 기능
  - 트리거가 많으면 많을수록 DBMS의 부하가 커지니 꼭 필요한 것만 만들어야한다
  - 이벤트의 가능한 예로는 테이블에 튜플 삽입, 테이블로부터 튜플 삭제, 테이블의 튜플 수정 등이 있고, 어떤 데이터 조회 시 알람 기능으로도 사용할 수도 있을 것임
  - 이벤트 전에 동작하는 트리거, 후에 동작하는 트리거로 구분된다
  - 참조 무결성이 트리거로 구현되있다
  - 연쇄 트리거에 제한이 없기에 주의해야한다, 잘못하면 무한루프 돌 수도 있음
- assertion
  - SQL3에 포함되어 있으나 대부분의 상용 관계 DBMS가 아직 지원하지 않는 기능
  - 트리거는 제약조건을 위반했을 때 수행할 동작을 명시하는 것이고, assertion은 제약조건을 위반하는 연산이 수행되지 않도록 막는 것
  - 트리거보다 좀 더 일반적인 무결성 제약 조건
  - DBMS는 assertion의 predicate를 검사하여 참이면 assertion을 위배하지 않는 경우이므로 데이터베이스 수정을 허용한다
  - 일반적으로 두 개 이상의 테이블에 영향을 미치는 제약조건을 명시하기 위해 사용됨

## 6. embedded SQL

- c, c++, java 등의 언어(호스트 언어)로 작성하는 프로그램에 SQL문을 삽입하여, 데이터베이스를 접근하는 부분을 SQL이 맡고 SQL에 없는 기능은 호스트 언어로 작성하는 것이 필요할 때 사용
- SQL이 호스트 언어의 완전한 표현력을 갖고 있지 않기 때문에 모든 질의를 SQL로 표현할 수는 없음
- SQL은 호스트 언어가 갖고 있는 조건문, 반복문, 입출력 등과 같은 동작, 사용자와의 상호 작용, 질의 결과를 GUI로 보내는 등의 기능을 갖고있지 않음
- 호스트 언어에 포함되는 SQL문을 내포된 SQL이라 부른다
- 데이터 구조가 불일치 하는 문제(impedance mismatch)가 발생하기도 한다
  - SQL은 릴레이션을 다루는 언어이고 호스트 언어는 레코드로 데이터를 다룸
- 컴파일러가 인식할 수 있도록 특별한 키워드를 만들어서 구분 짓는다
- 불일치 문제와 커서
  - 호스트 언어는 단일 변수 / 레코드 위주의 처리(튜플 단위)를 지원하는 반면 SQL은 데이터 레코드들의 처리(집합 단위)를 지원하기 때문에 불일치 문제가 발생함
  - 불일치 문제를 해결하기 위해서 커서가 사용됨
  - 커서는 한 번에 한 튜플씩 가져오는 수단, 즉 루프 돌면서 처리
  - DECLARE CURSOR문을 사용해서 커서를 정의
  - OPEN cursor문은 질의를 수행하고, 질의 수행 결과의 첫 번째 튜플 이전을 커서가 가리키도록 한다, 이것이 커서의 현재 튜플
  - 그 다음 fetch문은 커서를 다음 튜플로 이동시키고, 그 튜플의 애트리뷰트 값들을 fetch문에 명시된 호스트 변수들에 복사함
  - CLOSE cursor는 커서를 닫음
  - 파일 입출력과 과정이 비슷하다
- SQL 통신 영역(SQLCA)를 이용해서 호스트 프로그램과 DBMS가 통신해서 서로 정상적으로 됐는지 파악한다

# 2. 데이터베이스 설계와 ER 모델 2

<!--ts-->

- [2. 데이터베이스 설계와 ER 모델 2](#2-데이터베이스-설계와-er-모델-2)
  - [1. 새발 표기법(crow-feet)](#1-새발-표기법crow-feet)
  - [2. ER 스키마를 관계 모델의 릴레이션으로 매핑(논리적 설계)](#2-er-스키마를-관계-모델의-릴레이션으로-매핑논리적-설계)
  - [3. 레포지토리](#3-레포지토리)
  - [4. 정리](#4-정리)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 8월 28일 일요일 02시 39분 05초 KST -->

<!--te-->

## 1. 새발 표기법(crow-feet)

![Untitled](https://user-images.githubusercontent.com/48282185/187041689-a31ddd8c-ef85-4d1a-b935-254550d29494.png)

![Untitled 1](https://user-images.githubusercontent.com/48282185/187041669-9e13633d-66da-4d3f-bd80-5878f9f1f088.png)

- 수십 개 이상의 애트리뷰트가 엔티티 타입에 연결된 다이어그램을 나타내려면 매우 불편하고 공간을 많이 차지하기에 ER 다이어그램을 간소화해서 표현하자해서 등장한 방법
- 새발 표기법에도 여러가지 변형이 있음
- 관계의 카디날리니는 min, max라고 생각하자, 위의 예시에서 department min=1,max=1 ↔ project min=0,max=n, 참여 제약조건으로 생각하면 헷갈린다

## 2. ER 스키마를 관계 모델의 릴레이션으로 매핑(논리적 설계)

- 논리적 설계 단계에서는 ER 스키마를 관계 데이터 모델의 릴레이션들로 매핑한다
- ER 스키마에는 엔티티 타입과 관계 타입이 존재하지만 관계 데이터베이스에는 엔티티 타입과 관계 타입을 구분하지 않고 릴레이션들만 있음
- 릴레이션으로 매핑할 대상이 ER 스키마에서 엔티티 타입인지 또는 관계 타입인지, 엔티티 타입이라면 정규 엔티티 타입인지 또는 약한 엔티티 타입인지, 관계 타입이라면 이진 관계 타입인지 삼진 이상의 관계 타입인지, 애트리뷰트가 단일 값 애트리뷰트인지 또는 다치 애트리뷰트인지 등에 따라 매핑하는 방법이 달라짐
- ER 모델을 릴레이션들로 매핑하는 7개인 단계로 이루어진 알고리즘

  - 단계 1: 정규 엔티티 타입과 단일 값 애트리뷰트

    ![Untitled 2](https://user-images.githubusercontent.com/48282185/187041676-74596f09-6f10-4597-a5e0-fcd16126a3bc.png)

    - ER 스키마의 각 정규 엔티티 타입 E에 대해 하나의 릴레이션 R을 생성한다
    - E에 있던 단순 애트리뷰트들을 릴레이션 R에 모두 포함시킴
    - E에서 복합 애트리뷰트는 그 복합 애트리뷰트를 구성하는 단순 애트리뷰트들만 릴레이션 R에 포함시킴, 이를테면 주소가 도시, 구, 동으로 이루어진 복합 애트리뷰트라고 할 때, 도시, 구, 동을 R에 포함시키면 된다는 것, 이런 방식으로하면 어떤 것이 복합 애트리뷰트인지 알 수 없다는 한계가 있다
    - E의 기본 키가 릴레이션 R의 기본 키가 됨

  - 단계 2: 약한 엔티티 타입과 단일 값 애트리뷰트

    ![Untitled 3](https://user-images.githubusercontent.com/48282185/187041679-63c06288-9200-414f-b86a-35152e72548f.png)

    - ER 스키마에서 소유 엔티티 타입 E를 갖는 각 약한 엔티티 타입 W에 대하여 릴레이션 R을 생성함
    - W에 있던 모든 단순 애트리뷰트들을 릴레이션 R에 포함시킴
    - 소유 엔티티 타입에 해당하는 릴레이션의 기본 키를 약한 엔티티 타입에 해당하는 릴레이션에 외래 키로 포함시킴
    - 약한 엔티티 타입에 해당하는 릴레이션 R의 기본 키는 약한 엔티티 타입의 부분 키와 소유 엔티티 타입에 해당하는 릴레이션을 참조하는 외래 키의 조합으로 이루어진다

  - 단계 3: 이진 1:1 관계 타입

    ![Untitled 4](https://user-images.githubusercontent.com/48282185/187041681-06822d65-6f0a-4689-a057-0f986afd38ee.png)
    ![Untitled 5](https://user-images.githubusercontent.com/48282185/187041682-f86fa516-f976-4e8b-ad15-c04c8b163298.png)

    - ER 스키마의 각 이진 1:1 관계 타입 R에 대하여, R에 참여하는 엔티티 타입에 대응되는 릴레이션 S와 T를 찾음
    - S와 T 중에서 한 릴레이션을 선택하여, 만일 S를 선택했다면 T의 기본 키를 S에 외래 키로 포함시킴
    - S와 T 중에서 관계 타입에 완전하게 참여하는 릴레이션을 S의 역할을 하는 릴레이션으로 선택함
    - 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우애는 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 S에 대응되는 릴레이션에 포함시킴
    - 두 엔티티 타입이 관계 타입 R에 완전하게 참여할 때는 두 엔티티 타입과 관계 타입을 하나의 릴레이션으로 합치는 방법도 가능함(방법 4)
    - 방법 1, 2의 특징
      - 관계를 표현하기 위해 관계를 릴레이션으로 표현하는 대신 외래 키를 넣었지만, 관계를 표현하기 위함인지는 따로 문서로 작성하지 않는 이상 알 수 없다
      - 쿼리 조회 패턴에 따라 성능 차이가 날 수 있다, 만약 E1을 통해서 E2를 참조해야하는 패턴이 많이 발생하는데 방법 1처럼 구현되있다면 E2의 FK1을 풀스캔해서 현재 보고있는 E1을 찾아내야하지만, 방법 2의 경우 E2의 외래 키를 갖고있기 때문에 어떤 E2인지 바로 알 수 있다
      - 만약 관계에 애트리뷰트가 포함되야한다면 외래 키를 포함한 릴레이션에 넣어야하는데, 이게 그 릴레이션의 애트리뷰트인지 관계의 애트리뷰트인지 구분할 방법이 없다
    - 방법 3의 특징
      - 방법 1, 2의 한계를 이 방법을 통해 극복할 수 있지만, join횟수가 늘어나기에 성능이 저하돼어 주로 방법 1, 2가 쓰인다
    - 방법 4의 특징
      - 분명 독립적인 엔티티 타입 2개인데 합쳐놓으니 어떤 엔티티의 애트리뷰트인지 구분이 불가능하다
      - 성능 상으로는 좋다

  - 단계 4: 정규 이진 1:N 관계 타입

    ![Untitled 6](https://user-images.githubusercontent.com/48282185/187041683-d187e282-1ae2-4364-a649-74007c43a455.png)

    - 정규 이진 1:N 관계 타입 R에 대하여 N측의 참여 엔티티 타입에 대응되는 릴레이션 S를 찾는다
    - 관계 타입 R에 참여하는 1측의 엔티티 타입에 대응되는 릴레이션 T의 기본키를 릴레이션 S에 외래 키로 포함시킨다(T가 외래키를 가질 수는 없다, 만약 외래키를 집합형태로 가질 수 있다면 가능은 한데 원칙적으로 single value이기 때문)
    - N측의 릴레이션 S의 기본 키를 1측의 릴레이션 T에 외래 키로 포함시키면 애트리뷰트에 값들의 집합이 들어가거나 정보의 중복이 많이 발생함(같은 튜플이 여러개 생김)
    - 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우애는 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 S에 해당하는 릴레이션에 포함시킴

  - 단계 5: 이진 M:N 관계 타입

    ![Untitled 7](https://user-images.githubusercontent.com/48282185/187041684-8cd9b6fb-fcab-4121-9909-0fb0e3b967ea.png)

    - 이진 M:N 관계 타입 R에 대해서는 릴레이션 R을 생성함
    - 참여 엔티티 타입에 해당하는 릴레이션들의 기본 키를 릴레이션 R에 외래키로 포함시키고, 이들의 조합이 릴레이션 R의 기본 키가 됨
    - 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우에는 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 릴레이션 R에 포함시킴
    - 집합이기 때문에 E1, E2 어느쪽에도 붙일 수 없다

  - 단계 6: 삼진 이상의 관계 타입

    ![Untitled 8](https://user-images.githubusercontent.com/48282185/187041685-5e639301-10ba-4631-bdec-63bf2eeabf1a.png)

    - 삼진 이상의 각 관계 타입 R에 대하여 릴레이션 R을 생성함
    - 관계 타입 R에 참여하는 모든 엔티티 타입에 대응되는 릴레이션들의 기본 키를 릴레이션 R에 외래 키로 포함시킴
    - 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우애는 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 릴레이션 R에 포함시킴
    - 일반적으로 외래 키들의 조합이 릴레이션 R의 기본 키가 됨
    - 관계 타입 R에 참여하는 엔티티 타입들의 카디날리티가 1:N:N이면 카디날리티가 1인 릴레이션의 기본 키를 참조하는 외래 키를 제외한 나머지 외래 키들의 조합이 릴레이션 R의 기본 키가 됨(E1의 기본 키 없이도 식별 가능하기 때문)

  - 단계 7: 다치 애트리뷰트

    ![Untitled 9](https://user-images.githubusercontent.com/48282185/187041687-feb3226a-5d23-4454-850a-86809a6a2e07.png)

    - 각 다치 애트리뷰트에 대하여 릴레이션 R을 생성함
    - 다치 애트리뷰트에 해당하는 애트리뷰트를 릴레이션 R에 포함시키고, 다치 애트리뷰트를 애트리뷰트로 갖는 엔티티 타입이나 관계 타입에 해당하는 릴레이션의 기본 키를 릴레이션 R에 외래 키로 포함시킴
    - 릴레이션 R의 기본 키는 다치 애트리뷰트와 외래 키의 조합

## 3. 레포지토리

- 데이터베이스의 메타데이터를 위한 DB로 정보체계를 관리하기 위한 방법이다
- 유지 보수, 인수 인계 용이

## 4. 정리

![Untitled 10](https://user-images.githubusercontent.com/48282185/187041688-6e726ba5-9bb3-40d5-8a08-889aaac8ee8a.png)

> 출처
>
> - 이화여대 용환승 교수님 강의
> - 홍의경 저, MS SQL Server 기반 데이터베이스 배움터, 생능출판사, 2012년,
> - 이석호 저, 데이터베이스 시스템, 정익사, 2009.
> - A. Silberschatz, H. Korth, S. Sudarshan, "Database System Concepts," 6th Ed., McGraw-Hill, 2010.
> - Elmasri and Navathe, “ Fundamentals of Database Systems”, 6th ed. Addison-Wesley, 2010.
> - C.J.Date, “An Introduction to Database Systems (8th Edition)”, Addison-Wesley, 2003.
> - Won Kim, "Modern Database Systems," ACM Press, 1994

# 데이터베이스 설계와 ER모델 1

<!--ts-->

- [데이터베이스 설계와 ER모델 1](#데이터베이스-설계와-er모델-1)
  - [1. 데이터베이스 설계](#1-데이터베이스-설계)
  - [2. 개념적 수준의 모델](#2-개념적-수준의-모델)
  - [3. 데이터베이스 설계의 개요](#3-데이터베이스-설계의-개요)
  - [4. ER 모델](#4-er-모델)
  - [5. 엔티티](#5-엔티티)
  - [6. 애트리뷰트](#6-애트리뷰트)
  - [7. 관계와 관계 타입](#7-관계와-관계-타입)
  - [8. ER 스키마를 작성하기 위한 지침](#8-er-스키마를-작성하기-위한-지침)
  - [9. 데이터베이스 설계 과정 정리](#9-데이터베이스-설계-과정-정리)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 8월 27일 토요일 22시 19분 16초 KST -->

<!--te-->

## 1. 데이터베이스 설계

- 개념적 데이터베이스 설계와 물리적 데이터베이스 설계로 구분
- 개념적 데이터베이스 설계는 실제로 데이터베이스를 어떻게 구현할 것인가와는 독립적인 정보 사용의 모델을 개발하는 과정 → 엔티티와 릴레이션 설계
- 물리적 데이터베이스 설계에서는 물리적인 저장 장치와 접근 방식을 다룬다
- 개념적 데이터베이스 설계에서 과정에서 real world의 entity, relationship, process, 무결성 제약조건 등을 나타내는 추상화 모델을 구축
- 엔티티는 서로 구분되면서 real world에서 데이터베이스에 나타내려는 객체를 의미 = 테이블
- 관계는 두 개 이상의 엔티티들 간의 연관을 나타냄
- 프로세스는 관련된 활동을 나타냄
- 무결성 제약조건은 데이터의 정확성과 비즈니스 규칙을 의미

## 2. 개념적 수준의 모델

- 특정 데이터 모델과 독립적으로 응용 세계를 모델링할 수 있도록 함
- 데이터베이스 구조나 스키마를 top-down 방식으로 개발할 수 있기 위한 framework를 제공한다
- 인기 있는 개념적 수준의 모델은 엔티티 관계(ER, Entity-Relationship) 모델, 사실상의 표준(de-facto)
- ER 모델과 같은 개념적인 데이터 모델이 사상될 수 있는 다수의 구현 데이터모델이 존재함(implementation data model)
- 구현 단계에서 사용되는 세 가지 데이터 모델
  - 관계 데이터 모델, 계층 데이터 모델, 네트워크 데이터 모델

## 3. 데이터베이스 설계의 개요

- 개요

  ![Untitled](https://user-images.githubusercontent.com/48282185/187031891-788c70b1-3ba1-4389-a65f-7801a58e8a98.png)

  - 한 조직체의 운영과 목적을 지원하기 위해 데이터베이스를 생성하는 과정
  - 목적은 모든 주요 응용과 사용자들이 요구하는 데이터, 데이터 간의 관계를 표현하는 것
  - 데이터베이스 개발은 일반적인 프로젝트 라이프 사이클 과정을 따름
  - 훌륭한 데이터베이스 설계는 시간의 흐름에 따른 데이터의 모든 측면을 나타내고, 데이터 항목의 중복을 최소화하고, 데이터베이스에 대한 효율적인 접근을 제공하고, 데이터베이스의 무결성을 제공하고, 이해하기 쉬워야 한다
  - 논리적 설계의 결과물은 스키마다

- 데이터베이스 설계의 주요 단계

  ![Untitled 1](https://user-images.githubusercontent.com/48282185/187031864-05b95185-779f-463c-92a3-a08859fb8067.png)

  - 요구사항 분석, 개념적 설계, DBMS 선정, 논리적 설계, 스키마 정제, 물리적 설계와 튜닝 등 여러 작업 들로 이루어짐
  - 일반적으로, 데이터베이스 설계의 완성도를 높이기 위해서 이런 작업들을 앞뒤로 왔다갔다 할 수 있음, 했다고 끝이 아니라 수정을 계속 해줘야함

- 요구사항 수집과 분석
  - 흔히 기존의 문서를 조사하고, 인터뷰나 설문 조사 등이 시행됨
  - 요구사항에 관한 지식을 기반으로 관련 있는 엔티티들과 이들의 애트리뷰트들이 무엇인가, 엔티티 간의 관계가 무엇인가 등을 파악함
  - 데이터 처리에 관한 요구사항에 대하여 전형적인 연산들은 무엇인가, 연산들의 의미, 접근하는 데이터의 양 등을 분석함
- 개념적 설계
  - 모든 물리적인 사항과 독립적으로 한 조직체에서 사용되는 정보의 모델을 구축하는 과정
  - 사용자들의 요구사항 명세로부터 개념적 스키마가 만들어짐
  - 높은 추상화 수준의 데이터 모델을 기반으로 정형적인 언어로 데이터 구조를 명시함
  - 대표적인 데이터 모델이 ER모델
  - 개념적 설계의 단계에서는 엔티티 타입, 관계 타입, 애트리뷰트들을 식별하고, 애트리뷰트들의 도메인을 결정하고, 후보 키와 기본 키 애트리뷰트들을 결정함
  - 완성된 개념적 스키마(ER 스키마)는 ER 다이어그램으로 표현됨
- DBMS 선정
  - 여러 가지 요인들을 검토한 후 DBMS를 선정함
  - 기술적인 요인은 DBMS가 제공하는 데이터 모델, 저장 구조, 인터페이스, 질의어, 도구, 제공되는 서비스 등
  - 성능, 인터페이스, 가격 등 여러가지 복합적으로 고려해야함
- 논리적 설계
  - 데이터베이스 관리를 위해 선택한 DBMS의 데이터 모델을 사용하여 논리적 스키마(외부 스키마도 포함)를 생성한다
  - 개념적 스키마에 알고리즘을 적용하여 논리적 스키마를 생성함
  - 논리적 스키마를 나타내기 위해 관계 데이터 모델을 사용하는 경우에는, ER모델로 표현된 개념적 스키마를 관계 데이터베이스 스키마로 사상함
  - 관계 데이터베이스 스키마를 더 좋은 관계 데이터베이스 스키마로 변환하기 위해 정규화 과정을 거친다
  - 데이터베이스 설계자가 요구사항 수집과 분석 후에 바로 논리적 설계 단계로 가는 경우가 있는데, 이런 경우 흔히 좋은 관계 데이터베이스 스키마가 생성되지 않음
- 물리적 설계
  - 처리 요구사항들을 만족시키기 위해 저장 구조와 접근 경로 등을 결정함
  - 성능 상의 주요 기준은 몇 가지로 구분할 수 있음
    - 응답시간
      - 쿼리와 갱신이 평균적으로 또는 피크 시간 때 얼마나 오래 걸릴 것인가?
    - 트랜잭션 처리율(TPS)
      - 1초당 얼마나 많은 트랜잭션들이 평균적으로 또는 피크 시간 때 처리될 수 있는가?
    - 전체 데이터베이스에 대한 리포트를 생성하는데 얼마나 오래 걸릴 것인가?
- 트랜잭션 설계
  - 요구사항 수집과 분석 후에 데이터베이스 설계 과정과 별도로 트랜잭션 설계를 진행할 수 있음
  - 트랜잭션은 완성될 데이터베이스에서 동작할 응용 프로그램
  - 데이터베이스 스키마는 트랜잭션에서 요구하는 모든 정보를 포함해야 함
  - 검색, 갱신, 혼합 등 세 가지 유형으로 구분하여 입력과 출력, 동작 등을 식별함
  - 자주 쓰는 트랜잭션을 빨리할 수 있는 방향으로 튜닝

## 4. ER 모델

- 데이터베이스 설계를 용이하기 하기 위해 제안됨
- 현재는 EER(Enhanced ER)모델이 데이터베이스 설계 과정에 널리 사용되고 있음
- 개념적 설계를 위한 인기 있는 모델로서, 높은 수준으로 추상화하며 이해하기 쉽고 구문들의 표현력이 뛰어나고 사람들이 응용에 대해 생각하는 방식과 가깝다
- 실세계를 엔티티, 애트리뷰트, 관계로 표현함
- 쉽게 관계 데이터 모델로 사상됨
- 기본적인 구문으로는 엔티티, 관계, 애트리뷰트가 있고, 기타 구문으로는 카디날리티 비율, 참여 제약 조건 등이 있다

## 5. 엔티티

- 하나의 엔티티는 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 실세계의 객체
- 사원처럼 실체가 있는 것도 있지만 생각이나 개념과 같이 추상적인 것도 있음
- 엔티티 타입

  ![Untitled 2](https://user-images.githubusercontent.com/48282185/187031869-6cc28f25-0cf7-46a2-9eb4-6414d3cb079c.png)

  - 엔티티들은 엔티티 타입(또는 엔티티 집합)들로 분류된다
  - 엔티티 타입은 동일한 애트리뷰트들을 가진 엔티티들의 틀
    - 사람을 나타내는 애트리뷰트들 vs 새를 나타내는 애트리뷰트들
  - 엔티티 집합은 동일한 애트리뷰트들을 가진 엔티티들의 모임
  - 하나의 엔티티는 한 개 이상의 엔티티 집합에 속할 수 있음
  - 엔티티 타입은 관계 모델의 릴레이션의 내포에 해당하고, 엔티티 집합은 관계 모델의 릴레이션의 외연에 해당함
  - 엔티티 집합과 엔티티 타입을 엄격하게 구분할 필요는 없음, 같은 개념이다
  - ER 다이어그램에서 엔티티 타입은 직사각형으로 나타낸다

- 강한 엔티티 타입
  - 강한 엔티티 타입(정규 엔티티 타입)은 독립적으로 존재하며 엔티티 타입 내에서 자신의 키 애트리뷰트를 사용하여 고유하게 엔티티들을 식별할 수 있는 엔티티 타입
- 약한 엔티티 타입

  ![Untitled 3](https://user-images.githubusercontent.com/48282185/187031870-2c043b8c-4345-4683-8436-e6a97274d1ad.png)

  - 약한 엔티티 타입은 키를 형성하기에 충분한 애트리뷰트들을 갖지 못한 엔티티 타입
  - 이 엔티티 타입이 존재하려면 소유 엔티티 타입이 있어야 함 ⇒ 강한 엔티티에 의존
  - 소유 엔티티 타입의 키 애트리뷰트를 결합해야만 고유하게 약한 엔티티 타입의 엔티티들을 식별할 수 있음
  - 키를 형성하기에 충분한 애트리뷰트들을 갖지 못한 엔티티 타입
  - 약한 엔티티 타입에 키 애트리뷰트를 제공하는 엔티티타입을 소유 엔티티타입(owner entity type) 또는 식별 엔티티 타입(identifying entity type)이라고 부르고 이것들은 강한 엔티티 타입이다
  - ER 다이어그램에서 이중선 직사각형으로 표기하고 부분 키는 점선 밑줄을 그어 표기한다
  - 부분 키(partial key)는 약한 엔티티끼리 식별하기 위해 필요하고, 예시로 부양가족의 이름처럼 한 사원에 속한 부양가족내에서는 서로 다르지만 회사 전체 사원들의 부양가족들 전체에서는 같은 경우가 생길 수 있는 애트리뷰트, 전체로 식별할 때는 사원의 key와 함께 묶여야 식별 가능하다

- 은행 정보 시스템에서 대출을 월 단위로 상환한다고 했을 때, 대출은 강한 엔티티타입, 상환은 약한 엔티티 타입이이다, 왜냐면 상환은 대출에 의존하는 엔티티이고, 대출이 없다면 의미가 없기 때문임

## 6. 애트리뷰트

- 하나의 엔티티는 연관된 애트리뷰트들의 집합으로 설명됨
  - 예시로 사원 엔티티는 사원번호, 이름, 직책, 급여 등의 애트리뷰트를 갖는다
- 한 애트리뷰트의 도메인은 그 애트리뷰트가 가질 수 있는 모든 가능한 값들의 집합을 의미
  - 예시로 사원번호는 1000부터 9999까지의 값을 가질 수 있다고 할 때, 구간 [1000, 9999] 내의 정수는 사원번호의 도메인이 된다
- 여러 애트리뷰트가 동일한 도메인을 공유할 수 있음
  - 예시로 사원번호와 부서번호가 네 자리 정수를 가질 수 있음
- 키 애트리뷰트는 한 애트리뷰트 또는 애트리뷰트의 집합으로서 한 엔티티 타입 내에서 각 엔티티를 고유하게 식별함
- ER 다이어그램에서 기본 키에 속하는 애트리뷰트는 밑줄을 그어 표시함
- 요구사항 명세에서 명사나 형용사로 표현됨
- 엔티티는 독립적인 의미를 갖는데 반해서 애트리뷰트는 독립적인 의미를 갖지 않음
- 단순 애트리뷰트(simple attribute)

  ![Untitled 4](https://user-images.githubusercontent.com/48282185/187031872-9cea03cc-cb49-4ec4-9a7d-d7302c929f24.png)

  - 더 이상 다른 애트리뷰트로 나눌 수 없는 애트리뷰트
  - ER 다이어그램에서 실선 타원으로 표기
  - ER 다이어그램에서 대부분의 애트리뷰트는 단순 애트리뷰트

- 복합 애트리뷰트(composite attribute)

  ![Untitled 5](https://user-images.githubusercontent.com/48282185/187031873-2eb40ec7-f932-4f1a-a9ee-9bb2c2326f83.png)

  - 두 개 이상의 애트리뷰트로 이루어진 애트리뷰트
  - 동일한 엔티티 타입이나 관계 타입에 속하는 애트리뷰트들 중에서 밀접하게 연관된 것을 모아놓은 것
  - address는 복합 애트리뷰트이고, 도시, 구, 동, 우편번호가 합쳐져서 하나의 애트리뷰트를 이룬다

- 단일 값 애트리뷰트(single valued attribute)
  - 각 엔티팉마다 정확하게 하나의 값을 갖는 애트리뷰트
  - ER 다이어그램에서 단순 애트리뷰트와 동일하게 표현됨
  - 예시로 사원 번호 애트리뷰트는 어떤 사원도 두 개 이상의 사원번호를 갖지 않으므로 단일 값 애트리뷰트
  - ER 다이어그램에서 대부분의 애트리뷰트는 단일 값 애트리뷰트
- 다치 애트리뷰트(multi valued attribute)

  ![Untitled 6](https://user-images.githubusercontent.com/48282185/187031874-de84219f-11d1-42a4-b90e-adb9a656196c.png)

  - 각 엔티티마다 여러 개의 값을 가질 수 있는 애트리뷰트
  - ER 다이어그램에서 이중선 타원으로 표현함

- 저장된 애트리뷰트(stored attribute)
  - 다른 애트리뷰트와 독립적으로 존재하는 애트리뷰트
  - ER 다이어그램에서 단순 애트리뷰트와 동일하게 표현됨
  - ER 다이어그램에서 대부분의 애트리뷰트는 저장된 애트리뷰트
  - 예시로 사원 엔티티타입에서 사원 이름, 급여는 다른 애트리뷰트와 독립적으로 존재함
- 유도된 애트리뷰트(derived attribute)

  ![Untitled 7](https://user-images.githubusercontent.com/48282185/187031875-2ae28c47-1df7-46a0-9ab8-fd0267211595.png)

  - 다른 애트리뷰트의 값으로부터 얻어진 애트리뷰트
  - 관계 데이터베이스에서 릴레이션의 애트리뷰트로 포함시키지 않는 것이 좋음 ⇒ 왜?
  - ER 다이어그램에서 점선 타원으로 표현함
  - 예시로 나이는 매 해마다 바뀌기 때문에 현재 년도에서 생년월일을 빼서 유도할 수 있다

## 7. 관계와 관계 타입

![Untitled 8](https://user-images.githubusercontent.com/48282185/187031876-a83c50bf-a961-4e24-8c82-fe73c1e16873.png)

- 관계는 엔티티들 사이에 존재하는 연관이나 연결로서 두 개 이상의 엔티티 타입들 사이의 사상(mapping)으로 생각할 수 있음
- 관계 집합은 동질의 관계들의 집합
- 관계 타입은 동질의 관계들의 틀
- 관계 집합과 관계 타입을 엄격하게 구분할 필요는 없음, like entity
- 요구 사항 명세에서 흔히 동사는 ER 다이어그램에서 관계로 표현됨
  - 예시로 사원(엔티티)는 부서(엔티티)에서 근무한다(관계)
- ER 다이어그램에서 마름모로 표기
- 관계 타입이 서로 연관시키는 엔티티 타입들을 관계 타입에 실선으로 연결함
- 두 엔티티 사이에 여러 관계가 있을 수 있으니 어떤 관계인지 명확하게 표기해야한다
- 관계의 애트리뷰트

  ![Untitled 9](https://user-images.githubusercontent.com/48282185/187031879-4af92e2b-f33e-4b77-88ad-82cef39efe70.png)

  - 관계 타입은 관계의 특징을 기술하는 애트리뷰트들을 가질 수 있다
  - 관계 타입은 키 애트리뷰트를 갖지 않는다, 관계는 키를 갖는 의미가 없다, 그러면 관계를 어떻게 식별하느냐 하면 관계를 맺는 엔티티들의 프라이머리 키를 묶어서 식별한다

- 차수(degree)
  - 관계로 연결된 엔티티 타입들의 개수를 의미
  - 실세계에서 가장 흔한 관계는 두 개의 엔티티타입을 연결하는 이진 관계임
- 카디날리티(cardinality)

  ![Untitled 10](https://user-images.githubusercontent.com/48282185/187031880-d7836f93-cc45-43ce-9b13-7261e4dc823f.png)

  - 카디날리티 비율은 한 엔티티가 참여할 수 있는(반드시 참여해야하는 것은 아님) 관계의 수를 나타냄
  - 관계 타입에 참여하는 엔티티들의 가능한 조합을 재현함
  - 관계를 흔히 1:1, 1:N, M:N으로 구분
  - 카디날리티에 관한 정보는 간선 위에 나타냄
  - 어떤 관계냐에 따라 스키마 설계에 영향을 끼치기에 중요하다
  - 카디날리티 비율의 최소값과 최대값

    ![Untitled 11](https://user-images.githubusercontent.com/48282185/187031881-632e6791-5236-466b-b9d4-d32c62354036.png)

    - ER 다이어그램에서 관계타입과 엔티티 타입을 연결하는 실선 위에 (min, max) 형태로 표기
    - 어떤 관계 타입에 참여하는 각 엔티티 타입에 대하여 min은 이 엔티티 타입 내의 각 엔티티는 적어도 min번 관계에 참여함을 의미, 0이면 참여 안하는 거 허용, 1이면 반드시 한 번 이상은 참여
    - max는 이 엔티티 타입 내의 각 엔티티는 최대한 max번 관계에 참여함을 의미
    - max=\*는 어떤 엔티티가 관계에 임의의 수만큼 참여할 수 있음을 의미, max=1이면 1:1

- 역할(role)

  ![Untitled 12](https://user-images.githubusercontent.com/48282185/187031882-ef216349-cc19-4af1-8098-570882250fb6.png)

  - 관계 타입의 의미를 명확하게 하기 위해 사용됨
  - 특히 하나의 관계 타입에 하나의 엔티티 타입이 여러 번 나타나는 경우에는 반드시 역할을 표기해야함
  - 관계 타입의 간선 위에 표시
  - 예시로 어떤 엔티티가 supervises라는 관계에 1로 참여할 때는 supervisor 역할로 참여하는 것이고, N으로 참여할 때는 supervisee 역할로 참여하는 것임

- 전체 참여와 부분 참여

  ![Untitled 13](https://user-images.githubusercontent.com/48282185/187031883-8de72f3c-d338-4417-b08b-f72b7741f1b3.png)

  - 전체 참여는 어떤 관계에 엔티티 타입 E1의 모든 엔티티들이 관계 타입 R에 의해서 어떤 엔티티 타입 E2의 어떤 엔티티와 연관되는 것을 의미 ⇒ 관계에 참여하지 않는 엔티티가 없음
  - 부분 참여는 어떤 관계에 엔티티 타입 E1의 일부 엔티티만 참여하는 것을 의미 ⇒ 관계에 참여하지 않는 엔티티가 있을 수 있음
  - 전체 참여는 ER 다이어그램에서 이중 실선으로 표시
  - 카디날리티 비율과 함께 참여 제약조건은 관계에 대한 중요한 제약 조건으로 작용한다

- 다중 관계

  ![Untitled 14](https://user-images.githubusercontent.com/48282185/187031885-4fd1e6a4-b262-4ff6-99ac-1abdf08f8121.png)

  - 두 엔티티 타입 사이에 두 개 이상의 관계 타입이 존재할 수 있음
  - 이러한 케이스 때문에 관계를 명시해야한다

- 순환적 관계

  ![Untitled 15](https://user-images.githubusercontent.com/48282185/187031886-6b78a0d0-1669-4c05-a2dd-168b474d54d5.png)

  - 하나의 엔티티 타입이 동일한 관계 타입에 두 번 이상 참여하는 것

## 8. ER 스키마를 작성하기 위한 지침

- 엔티티는 키 애트리뷰트 이외에 설명 정보를 추가로 가진다
- 다치 애트리뷰트는 엔티티로 분류해야 함
- 애트리뷰트들이 직접적으로 설명하는 엔티티에 애트리뷰트들을 붙임
- 가능한 한 복합 식별자를 피한다
- 관계는 일반적으로 독자적으로 존재할 수 없지만 엔티티 타입과 관계 타입을 절대적으로(기준이 있는 것이 아님, 설계자 재량) 구분하는 것은 어려움
  ![Untitled 16](https://user-images.githubusercontent.com/48282185/187031888-981d41bc-ddbe-4221-a831-1cf166708907.png)

## 9. 데이터베이스 설계 과정 정리

- 응용의 요구사항을 수집하여 기술
- 응용과 연관이 있는 엔티티 타입들을 식별
- 응응과 연관이 있는 관계 타입들을 식별
- 관계가 1:1, 1:N, M:N 중에서 어느 것에 해당하는지 결정
- 엔티티 타입과 관계 타입들에 필요한 애트리뷰트를 식별하고, 각 애트리뷰트가 가질 수 있는 값들의 집합(도메인)을 식별
- 엔티티 타입들의 식별을 위한 기본 키를 식별
- 응용을 위한 ER 스키마 다이어그램을 작성
- ER 스키마 다이어그램이 응용에 대한 요구사항과 부합되는지 검사
- ER 스키마 다이어그램을 DBMS에서 사용되는 데이터베이스 모델로 변환(개념 데이터 모델 → 논리 데이터 모델)
- ER 표기법 요약
  ![Untitled 17](https://user-images.githubusercontent.com/48282185/187031889-7872518b-911e-47ba-9ecd-1c5c641183e1.png)

> 출처
>
> - 이화여대 용환승 교수님 강의
> - 홍의경 저, MS SQL Server 기반 데이터베이스 배움터, 생능출판사, 2012년,
> - 이석호 저, 데이터베이스 시스템, 정익사, 2009.
> - A. Silberschatz, H. Korth, S. Sudarshan, "Database System Concepts," 6th Ed., McGraw-Hill, 2010.
> - Elmasri and Navathe, “ Fundamentals of Database Systems”, 6th ed. Addison-Wesley, 2010.
> - C.J.Date, “An Introduction to Database Systems (8th Edition)”, Addison-Wesley, 2003.
> - Won Kim, "Modern Database Systems," ACM Press, 1994

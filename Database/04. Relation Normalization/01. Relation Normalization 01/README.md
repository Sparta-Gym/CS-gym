# 1. 릴레이션 정규화 1

<!--ts-->

- [1. 릴레이션 정규화 1](#1-릴레이션-정규화-1)
  - [1. 릴레이션의 정규화](#1-릴레이션의-정규화)
  - [2. 좋은 관계 데이터베이스 스키마를 설계하는 목적](#2-좋은-관계-데이터베이스-스키마를-설계하는-목적)
  - [3. 갱신 이상(Update anomaly)](#3-갱신-이상update-anomaly)
  - [4. 정규화 개요](#4-정규화-개요)
  - [5. 릴레이션 분해(decompose)](#5-릴레이션-분해decompose)
  - [6. 정규형(normal form)의 종류](#6-정규형normal-form의-종류)
  - [7. 관계 데이터베이스 설계의 비공식적인 지침](#7-관계-데이터베이스-설계의-비공식적인-지침)
  - [8. 함수 종속성](#8-함수-종속성)
  - [9. 완전 함수 종속성(FFD, Full Functional Dependency)](#9-완전-함수-종속성ffd-full-functional-dependency)
  - [10. 이행적 함수 종속성(transitive FD)](#10-이행적-함수-종속성transitive-fd)
  - [11. 릴레이션 분해 과정](#11-릴레이션-분해-과정)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 8월 30일 화요일 05시 43분 27초 KST -->

<!--te-->

## 1. 릴레이션의 정규화

- 부주의한 데이터베이스 설계는 제어할수 없는 데이터 중복을 야기하여 여러 가지 갱신 이상(update anomaly)을 유발함
- 어떻게 좋은 데이터베이스 설계를 할 것인가?, 데이터베이스에 어떤 릴레이션들을 생성할 것인가?, 각 릴레이션에 어떤 애트리뷰트들을 둘 것인가?에 관한 주제
- 정규화(normalization)는 주어진 릴레이션 스키마를 함수적 종속성(갱신 이상이 발생하는 이유)과 기본 키를 기반으로 분석하여, 원래의 릴레이션을 분해함으로서 중복과 세 가지(insert, delete, update) 갱신 이상을 최소화함

## 2. 좋은 관계 데이터베이스 스키마를 설계하는 목적

- 정보의 중복과 갱신 이상이 생기지 않도록 하고, 정보의 손실을 막으며, 실세계를 훌륭하게 나타내고, 애트리뷰트들 간의 관계가 잘 표현되는 것을 보장하며, 어떤 무결성 제약조건의 시행을 간단하게 하며, 아울러 효율성 측면도 고려하는 것
- 먼저 갱신 이상이 발생하지 않도록 노력하고, 그 다음에 효율성을 고려함

## 3. 갱신 이상(Update anomaly)

- 레코드 하나를 기준으로 한다
- 수정 이상(modification anomaly)
  - 반복된 데이터 주에 일부만 수정하면 데이터 불일치가 발생
  - 데이터 하나를 수정하려고 봤더니 중복돼서 모든 중복을 다 바꿔줘야됨
- 삽입 이상(insertion anomaly)
  - 불필요한 정보를 함께 저장하지 않고는 어떤 정보를 저장하는 것이 불가능
- 삭제 이상(deletion anomaly)
  - 유용한 정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능

## 4. 정규화 개요

- 나쁜 설계 예시

  - 사원 릴레이션은 회사의 사원에 관환 정보를 저장하는 릴레이션이다
  - 이 회사에서는 각 사원이 두 개 이하의 부서에 속할 수 있다
  - 예시 1

    ![Untitled](https://user-images.githubusercontent.com/48282185/187295415-135828bb-601c-4ef8-a33b-34f60a29468e.png)

    - 엔티티는 서로 독립적으로 존재할 수 있는 정보의 집합인데, 이 예시에서는 사원 엔티티와 부서 엔티티를 묶어 놨다
    - 부서를 최대 2개까지밖에 표현하지 못한다

  - 예시 2

    ![Untitled 1](https://user-images.githubusercontent.com/48282185/187295372-e93608cc-1138-490d-92a3-b9a49c8b4a77.png)

    - 부서 수를 제한할 필요가 없어졌지만 아래의 문제들이 발생
    - 각 사원이 속한 부서 수 만큼 동일한 사원의 튜플들이 존재하므로 사원이름, 사원번호, 주소, 전화번호 등이 중복되어 저장 공간 낭비가 발생함
    - 수정이상으로 인해 데이터베이스가 불일치 상태(inconsistency)에 빠짐

      - 위 예시가 좀 이해하기 어려워서 다른 예시를 참고했음

        [[데이터베이스] 이상(Anomaly)](https://kosaf04pyh.tistory.com/294)

    - 만일 어떤 부서를 신설했는데 아직 사원을 한 명도 배정하지 않았다면 이 부서에 관한 정보를 입력할 수 없음 → 삽입 이상 → 부서 정보를 입력하기 위해서는 사원 정보도 필요함
    - 만일 어떤 부서에 속한 사원이 단 한 명이 있는데, 이 사원에 관한 튜플을 삭제하면 이 사원이 속한 부서에 관한 정보도 릴레이션에서 삭제됨 → 삭제 이상

## 5. 릴레이션 분해(decompose)

- 각종 갱신 이상을 해결하기 위한 기법
- 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것
- 릴레이션의 분해는 필요한 경우에는 분해된 릴레이션들로부터 원래의 릴레이션을 다시 구할 수 있음을 보장해야 한다는 원칙을 기반
- 분해를 잘못하면 두 릴레이션으로부터 얻을 수 있는 정보가 원래의 릴레이션이 나타내던 정보보다 적을 수도 있고 많을 수도 있다
- 릴레이션의 분해는 릴레이션에 존재하는 함수 종속성에 관한 지식을 기반으로 한다

## 6. 정규형(normal form)의 종류

- 제 1 정규형(first normal form)
- 제 2 정규형(second normal form)
- 제 3 정규형(third normal form)
- BCNF(boyce-codd normal form)
- 이외에도 더 있지만 일반적으로 BCNF까지만 해도 충분하다

## 7. 관계 데이터베이스 설계의 비공식적인 지침

- 지침 1: 이해하기 쉽고 명확한 스키마를 만들라
  - 여러 엔티티 타입이나 관계 타입에 속한 애트리뷰트들을 하나의 릴레이션에 포함시키지 않는다
- 지침2: null값을 피하라
  - 설계가 잘못됨을 방증
- 지침 3: 가짜 튜플이 생기지 않도록 하라
  - 실제 세계에는 있을 수 없는 데이터
  - 설계가 잘못됨을 방증
- 지침 4: 스키마를 정제하라

## 8. 함수 종속성

- 정규화 이론의 핵심
- 릴레이션의 애트리뷰트들의 의미로부터 결정됨
- 애트리뷰트들 사이의 관계
- 릴레이션 스키마에 대한 관계이지, 릴레이션의 특정 인스턴스에 대한 관계가 아님
- 릴레이션의 가능한 모든 인스턴스들이 관계를 만족해야 함
- 실세계에 대한 지식과 응용의 의미를 기반으로 어떤 함수 종속성들이 존재하는가를 파악해야 함
- 함수 종속성은 제2정규형부터 BCNF까지 적용됨
- 결정자(determinant)
  - 어떤 애트리뷰트 값은 다른 애트리뷰트의 값을 고유하게 결정할 수 있음
    - 수학의 함수에서 x에 의해 y가 결정되는 것과 같음
  - 결정자는 주어진 릴레이션에서 다른 애트리뷰트(또는 애트리뷰트들의 집합)를 고유하게 결정하난 하나 이상의 애트리뷰트를 의미
  - 결정자를 A → B로 표기하고, 이를 A가 B를 결정한다(또는 A는 B의 결정자이다)라고 표현한다
  - 모든 키들은 다른 애트리뷰트들을 결정한다
  - 예시로 사원 릴레이션에서 사원번호는 사원이름을 고유하게 결정하지만 주소는 사원이름을 고유하게 결정하지 못한다
- 예시

  ![Untitled 2](https://user-images.githubusercontent.com/48282185/187295386-8bd5e0a4-5ab5-416f-b5ad-14f67cce2773.png)

  - 사원번호와 부서번호 쌍이 키가 된다, 사원에 대한 정보만 있는게 아니기 때문
  - 사원번호가 정해지면 사원이름, 주소, 전화번호가 정해진다
  - 부서번호가 정해지면 부서이름이 정해진다

- 만일 애트리뷰트 A가 애트리뷰트 B의 결정자이면 B가 A에 함수적으로 종속한다고 말하는데, 이것을 다르게 표현하면 릴레이션 R에서 애트리뷰트 B가 애트리뷰트 A에 함수 종속한다는 필요 충분 조건은 각 A에 대해 반드시 한 개의 B값이 대응된다는 것
  - 위 예시에서 사원번호가 사원이름, 주소, 전화번호의 결정자이므로 사원이름, 주소, 전화번호는 사원번호에 함수 종속한다
  - 위 예시에서 직책은 (사원번호, 부서번호)에 함수적으로 종속하지, 사원번호 단독으로 종속하지는 않는다, 한 사원이 여러 부서에 속할 수 있고 이에 따라 직책이 변화되기 때문임
- 갱신 이상이 발생한 이유는 한 릴레이션에 여러 함수 종속관계가 분산돼있기 때문이다, 이를 없애려면 릴레이션 분해가 필요하다
  - 하나가 정해지면 다른 것도 정해지는 것이 함수 종속이고, 갱신 이상은 바뀌어야하는 것이 안 바뀌거나, 필요없는 것도 같이 삽입되거나, 없어지지 말아야될 것도 없어지거나 셋 중 하나

## 9. 완전 함수 종속성(FFD, Full Functional Dependency)

![Untitled 3](https://user-images.githubusercontent.com/48282185/187295392-fee40098-973c-459c-9405-0eea8f0ee5ff.png)

![Untitled 4](https://user-images.githubusercontent.com/48282185/187295397-3fa8d75b-2d28-484d-8350-4692b0542461.png)

- 릴레이션 R에서 애트리뷰트 B가 애트리뷰트 A에 함수 종속하면서 A의 어떠한 진부분 집합에도 함수 종속하지 않으면 B가 A에 완전하게 함수 종속한다고 표현한다
- 여기서 A는 복합 애트리뷰트이다
- 복합 애트리뷰트에 종속되는 것을 완전 / 복합 애트리뷰트의 진부분 집합에 종속되는 것을 부분 함수 종속으로 나눈다
  - 예시에서 복합 애트리뷰트 (사원번호, 부서번호)가 직책의 결정자이다 → 완전 함수 종속성(fd3)
  - 예시에서 복합 애트리뷰트의 부분 집합 (사원번호)는 사원이름, 주소, 전화번호의 결정자이다 → 부분 함수 종속(fd1)
  - 예시에서 복합 애트리뷰트의 부분 집합 (부서번호)는 부서이름의 결정자이다 → 부분 함수 종속(fd2)
- 한 릴레이션에 여러 복잡한 함수 종속 관계들이 있는 경우 이것들을 분리하여 제일 simple한 함수 종속 관계만 남기는 것이 정규화이다

## 10. 이행적 함수 종속성(transitive FD)

![Untitled 5](https://user-images.githubusercontent.com/48282185/187295400-6517de94-15c7-48b3-b4f3-1d37bcfa1101.png)

- 한 릴레이션의 애트리뷰트 A, B, C가 주어졌을 때 애트리뷰트 C가 이행적으로 A에 종속한다(A → C)는 것의 필요 충분 조건은 A → B and B → C가 성립하는 것 (삼단 논법)
- A가 릴레이션의 기본 키라면 키의 정의에 따라 A → B와 A → C가 성립, 만일 C가 A외에 B에도 함수적으로 종속한다면 C는 A에 직접 함수적으로 종속하면서 B를 거쳐서 A에 이행적으로 종속
- 예시로 학번 → 학과이름가 성립하고 학과이름 → 학과전화번호가 성립하므로 이행적 함수 종속성인 학번 → 학과전화번호가 성립

## 11. 릴레이션 분해 과정

- 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것
- 릴레이션을 분해하면 중복이 감소되고 갱신 이상이 줄어드는 장점이 있는 반면에, 바람직하지 않은 문제들을 포함하여 몇 가지 잠재적인 문제들을 야기할 수 있다
  - 릴레이션이 분해되기 전에는 조인이 필요 없는 쿼리였는데, 분해 후에는 조인을 필요로 하는 쿼리로 바뀔 수 있음 → trade-off
  - 분해된 릴레이션들을 사용하여 원래 릴레이션을 재구성하지 못할 수 있음
- 무손실 분해(lossless decomposition)
  - 여기서 손실은 정보의 손실을 뜻함
  - 정보의 손실은 원래의 릴레이션을 분해한 후에 생성된 릴레이션들을 조인한 결과에 들어 있는 정보가 원래의 릴레이션에 들어 있는 정보보다 적거나 많은 것을 모두 포함
  - 분해된 두 릴레이션을 조인하면 원래의 릴레이션에 들어 있는 정보를 완전하게 얻을 수 있음
- 예시

  ![Untitled 6](https://user-images.githubusercontent.com/48282185/187295403-2a473559-cff2-4e54-bc05-4faddc9794f9.png)

  - 한 학생이 과목을 더 들을 때마다 정보가 계속 중복됨
  - 함수 종속성
    - 학번 → 이름, 이메일
    - 이메일 → 학번, 이름
    - (학번, 과목번호) → 학점
  - 무손실 분해

    ![Untitled 7](https://user-images.githubusercontent.com/48282185/187295406-6eedbf6e-d481-476c-b96a-245438fb6c46.png)

    - join했을 때 원래의 정보를 얻을 수 있음

      ![Untitled 8](https://user-images.githubusercontent.com/48282185/187295409-d2066e6b-d3a3-4a7a-9263-f931f720ee48.png)

    - 무손실 분해이긴 하지만 불필요한데, join이 계속 발생하기 때문에 굳이 나눌 필요는 없다

  - 안 좋은 분해 예시

    ![Untitled 9](https://user-images.githubusercontent.com/48282185/187295412-fe9089fd-d159-4fa3-822a-ea37a0a73a0f.png)

    - 학점은 (학번, 과목번호) 쌍으로 결정되는데 수강 2 테이블에서의 학점은 그 의미가 사라진다
    - 학생이 어떤 과목을 들어서 저 학점을 받았는지 알 수 없고, 원래 테이블을 만들 수 없음
    - 수강1과 수강2를 join을 하게되면 실세계 없던 정보(가짜 튜플)이 생김

> 출처
>
> - 이화여대 용환승 교수님 강의
> - 홍의경 저, MS SQL Server 기반 데이터베이스 배움터, 생능출판사, 2012년,
> - 이석호 저, 데이터베이스 시스템, 정익사, 2009.
> - A. Silberschatz, H. Korth, S. Sudarshan, "Database System Concepts," 6th Ed., McGraw-Hill, 2010.
> - Elmasri and Navathe, “ Fundamentals of Database Systems”, 6th ed. Addison-Wesley, 2010.
> - C.J.Date, “An Introduction to Database Systems (8th Edition)”, Addison-Wesley, 2003.
> - Won Kim, "Modern Database Systems," ACM Press, 1994

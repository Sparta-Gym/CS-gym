# 2. 릴레이션 정규화 2

<!--ts-->

- [2. 릴레이션 정규화 2](#2-릴레이션-정규화-2)
  - [1. 제1정규형(1NF)](#1-제1정규형1nf)
  - [2. 제2정규형(2NF)](#2-제2정규형2nf)
  - [3. 제3정규형(3NF)](#3-제3정규형3nf)
  - [4. BCNF](#4-bcnf)
  - [5. 정규화 요약](#5-정규화-요약)
  - [6. 역정규화(denormalization)](#6-역정규화denormalization)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 8월 30일 화요일 17시 28분 45초 KST -->

<!--te-->

## 1. 제1정규형(1NF)

![Untitled](https://user-images.githubusercontent.com/48282185/187388396-f603aa15-6e3d-46f2-941c-7cf89336bccb.png)

- 릴레이션 R이 제1정규형을 만족할 필요 충분 조건은 R의 모든 애트리뷰트가 원자 값(=단일 값)만을 갖는 다는 것이다
- 즉 릴레이션의 모든 애트리뷰트에 반복 그룹(repeating group)이 나타나지 않으면 제1정규형을 만족함
- 모든 릴레이션은 제1정규형이다
- 위 예시에서 과목번호에 원자값이 아닌 집합이 들어가있기에 예시 릴레이션은 제1정규형이 아니다
- 제1정규형을 만족하지 않는 반복그룹을 갖는 릴레이션을 제1정규형으로 변환하는 방법

  ![Untitled 1](https://user-images.githubusercontent.com/48282185/187388344-771d8a12-6593-4b83-867f-116b2f1f9b51.png)

  - 반복 그룹 애트리뷰트에 나타나는 집합에 속한 각 값마다 하나의 튜플로 표현

- 제1정규형으로 충분한가?

  ![Untitled 2](https://user-images.githubusercontent.com/48282185/187388360-1eb7ff6a-48ed-4ece-81ca-8a5737840ce0.png)

  - 여전히 갱신 이상이 발생한다 → 1 record가 갱신될 때다, not table 전체
  - 수정 이상
    - 학과 전화번호가 바뀐 상황
    - 한 학과에 소속한 학생 수 만큼 그 학과의 전화번호가 중복되어 저장되므로 여러 학생이 소속된 학과의 전화번호가 변경되었을 때 그 학과에 속한 모든 학생들의 튜플에서 전화번호를 수정하지 않으면 일관성이 깨진다
  - 삽입 이상
    - 한 명의 학생이라도 어떤 학과에 소속되지 않으면 이 학과에 관한 튜플을 삽입할 수 없음, 왜냐하면 학번이 기본 키의 구성요소인데 엔티티 무결성 제약조건에 따라 기본 키에 null값을 입력할 수 없기 때문임
  - 삭제 이상
    - 한 학과에 한 명의 학생만 있는 상황
    - 어떤 학과에 소속된 마지막 학생의 튜플을 삭제하면 이 학생이 소속된 학과에 관한 정보도 삭제됨

- 갱신 이상이 생기는 이유
  - 기본 키에 대한 부분 함수 종속성이 있기 때문
  - 학번(기본 키) → 학과 이름, 학과 전화번호
  - (학번, 과목번호) → 학점
- 해결 방안

  - 부분 함수 종속성이 존재하지 않도록 두 릴레이션으로 분해한다

    ![Untitled 3](https://user-images.githubusercontent.com/48282185/187388371-854b50d1-9b67-4942-8db1-c5b3f00166b7.png)

## 2. 제2정규형(2NF)

- 릴레이션 R이 제2정규형을 만족할 필요 충분 조건은 R이 제1정규형을 만족하면서, 어떤 후보 키에도 속하지 않는 모든 애트리뷰트들이 R의 기본 키에 완전하게 함수적으로 종속하는 것
- 기본 키가 두 개 이상의 애트리뷰트들로 구성되었을 경우(복합 애트리뷰트)에만 제1정규형이 제2정규형을 만족하는가를 고려할 필요가 있음
- 완전 / 부분 함수종속이 생기는 경우는 기본 키가 복합 애트리뷰트일 때만 해당됨, 왜냐하면 정의를 보면 진부분 집합을 갖는다는 뜻은 나눠짐을 의미하고 이것은 복합 애트리뷰트임을 의미하는 것이기 때문, 기본 키가 안일 애트리뷰트인 경우는 무조건 완전 함수적 종속을 갖는다는 의미
- 제2정규형으로 충분한가?

  ![Untitled 4](https://user-images.githubusercontent.com/48282185/187388374-42f2cb01-8316-4d8d-a9d7-98ceef079be1.png)

  - 정답부터 말하자면 아니다
  - 수정 이상
    - 여러 학생이 소속된 학과의 전화번호가 변경되었을 때 그 학과에 속한 모든 학생들의 튜플에서 전화번호가 수정되지 않으면 데이터베이스의 일관성이 유지되지 않음
  - 삽입 이상
    - 어떤 학과를 신설해서 아직 소속 학생이 없으면 그 학과의 정보를 입력할 수 없다 왜냐하면 학번이 기본 키인데 엔티티 무결성 제약조건에 따라 기본 키에 null값을 입력할 수 없기 때문
  - 삭제 이상
    - 어떤 학과에서 마지막 학생의 튜플이 삭제되면 그 학과의 전화번호도 함께 삭제됨

- 제2정규형에서 갱신이상이 발생하는 이유

  ![Untitled 5](https://user-images.githubusercontent.com/48282185/187388380-fb586ee7-7eb8-43c2-bbe0-7ddc26d325ab.png)

  - 이행적 종속성이 존재하기 때문임
  - 위 예시에서는 학번이 학과 이름과 학과 전화번호를 결정하고 학과가 학과 전호번호를 결정하는 이행적 종속성이 있다

- 해결방안
  - 이행적 종속이 존재하지 않도록 두 릴레이션으로 분해한다

## 3. 제3정규형(3NF)

- 릴레이션 R이 제3정규형을 만족할 필요 충분 조건은 R이 제2정규형을 만족하면서, 키가 아닌 모든 애트리뷰트가 R의 기본키에 이행적으로 종속하지 않는 것
- 현업에서 대부분 제3정규형이면 문제가 없지만 그래도 예외는 있다
- 예외

  - 각 학생은 여러 과목을 수강할 수 있고, 각 강사는 한 과목만 가르침
  - 기본 키는 (학번, 과목)
  - 키가 아닌 강사 애트리뷰트가 기본 키에 완전하게 함수적으로 종속하므로 제2정규형을 만족하고, 강사가 기본키에 직접 종속하므로 제3정규형도 만족함

    ![Untitled 6](https://user-images.githubusercontent.com/48282185/187388382-66b77a12-2b28-42e4-a5b9-f853882a14ef.png)

  - 수정 이상
    - 여러 학생이 수강 중인 어떤 과목의 강사가 변경되었을 때 그 과목을 수강하는 모든 학생들의 튜플에서 강사를 수정하지 않으면 데이터베이스의 일관성이 유지되지 않음
  - 삽입 이상
    - 어떤 과목을 신설하여 아직 수강하는 학생이 없으면 어떤 강사가 그 과목을 가르친다는 정보를 입력할 수 없음 왜냐하면 학번이 기본 키를 구성하는 애트리뷰트인데 엔티티 무결성 제약조건에 따라 기본 키를 구성하는 애트리뷰트에 null값을 입력할 수 없기 때문
  - 삭제 이상
    - 어떤 과목을 이수하는 학생이 한 명빡에 없는데 이 학생의 튜플을 삭제하면 그 과목을 가르치는 강사에 관한 정보도 함께 삭제됨

- 갱신 이상이 생기는 이유
  - 키가 아닌 애트리뷰트가 다른 애트리뷰트를 결정하기 때문
  - 위 예시에서는 강사가 과목을 결정
  - 위 예시의 후보 키는 (학번, 과목)과 (학번, 강사)

## 4. BCNF

- 릴레이션 R이 BCNF를 만족할 필요 충분 조건은 R이 제3정규형을 만족하면서, 모든 결정자가 후보 키이어야 함
- 위의 예시에서 강사 애트리뷰트는 후보 키가 아님에도 불구하고 과목 애트리뷰트를 결정하기 때문에 BCNF가 아님
- 제3정규형을 만족하는 대부분을 릴레이션은 BCNF도 만족함
- 하나의 후보 키만을 가진 릴레이션이 제3정규형을 만족하면 동시에 BCNF도 만족함
- 후보 키라는 것은 선택만 안됐을 뿐이지 기본 키가 될수도 있는 것들이기에 여기에 종속하면 문제 없다
- 제3정규형이면서 BCNF가 아닌 것들은 키가 아닌 어떤 애트리뷰트 A가 키를 이루는 어떤 애트리뷰트 종속한다고 볼 수도 있다, 만일 A가 키에 속하지 않는 애트리뷰트 B를 종속한다고 하면, 이행적 종속성이 생기기 때문에(키 → A, A → B) 제3정규형을 만족하지 않기 때문
- 제3정규형을 만족하는 릴레이션을 BCNF로 정규화

  ![Untitled 7](https://user-images.githubusercontent.com/48282185/187388386-cc4d9437-e2a7-4b4c-942f-cb5d504170c2.png)

  - 키가 아니면서 결정자 역할을 하는 애트리뷰트와 그 결정자에 함수적으로 종속하는 애트리뷰트를 하나의 테이블에 넣음, 이 릴레이션에서 결정자는 기본 키가 됨
  - 기존 릴레이션에서 결정자를 남겨서 기본 키의 구성요소가 되도록 함 또한 이 결정자는 새로운 릴레이션에 대한 외래키 역할도 함

- 제3정규형을 BCNF로 정규화한 예시

  ![Untitled 8](https://user-images.githubusercontent.com/48282185/187388388-c460cc0f-9fb2-408f-90ef-e672fb910d3e.png)

## 5. 정규화 요약

![Untitled 9](https://user-images.githubusercontent.com/48282185/187388394-a17ec6b6-36e6-45b4-8003-b46bf9646ccb.png)

## 6. 역정규화(denormalization)

- 역정규화는 보다 낮은 정규형으로 되돌아 가는 것을 의미
- 정규화 단계가 진행될수록 중복이 감소하고 갱신 이상도 감소함
- 정규화가 진전될수록 무결성 제약조건을 시행하기 위해 필요한 코드의 양도 감소됨
- 정규화가 데이터베이스 설계의 중요한 요소이지만 성능 관점으로 보면 높은 정규형을 만족하는 릴레이션 스키마가 최적인 것은 아님 → 분해 전보다 join 횟수가 늘어나기 때문
  - 한 정규형에서 다음 정규형으로 진행될 때마다 하나의 릴레이션이 최소한 두 개의 릴레이션으로 분해됨
  - 분해되기 전의 릴레이션을 대상으로 쿼리를 날릴 때는 join이 필요 없지만 분해된 릴레이션을 대상으로 쿼리를 날릴 때는 같은 정보를 얻기 위해서 보다 많은 릴레이션들을 접근해야하므로 join의 필요성이 증가함
- 때로는 DBA는 애플리케이션의 요구 사항에 따라 데이터베이스 설계의 일부분을 역정규화함으로써 데이터 중복 및 갱신 이상을 대가로 치르면서 성능상의 요구를 만족시키기도 함
- 많의 데이터베이스 응용에서 검색 쿼리의 비율이 갱신 쿼리의 비율보다 훨씬 높음, 역 정규화는 주어진 응용에서 빈번하게 수행되는 검색 쿼리들의 수행 속도를 높이기 위해서 이미 분해된 두 개 이상의 릴레이션들을 합쳐서 하나의 릴레이션으로 만드는 작업
- 정규화의 기본 원칙이 분해 전 릴레이션으로 되돌아갈 수 있어야 하는 것이었기에 조인하면 다시 원래의 릴레이션으로 돌아갈 수 있다

> 출처
>
> - 이화여대 용환승 교수님 강의
> - 홍의경 저, MS SQL Server 기반 데이터베이스 배움터, 생능출판사, 2012년,
> - 이석호 저, 데이터베이스 시스템, 정익사, 2009.
> - A. Silberschatz, H. Korth, S. Sudarshan, "Database System Concepts," 6th Ed., McGraw-Hill, 2010.
> - Elmasri and Navathe, “ Fundamentals of Database Systems”, 6th ed. Addison-Wesley, 2010.
> - C.J.Date, “An Introduction to Database Systems (8th Edition)”, Addison-Wesley, 2003.
> - Won Kim, "Modern Database Systems," ACM Press, 1994
